<tool id="gatk3.3_depth_of_coverage" name="Depth of Coverage" version="GATK3.3: GenomeAnalysisTK-3.3-0; SAMTOOLS: 1.1">
  <description>on BAM files</description>
  <requirements>
      <requirement type="package" version="3.3">gatk3</requirement>
      <requirement type="package" version="1.1">samtools</requirement>
  </requirements>
  <macros>
    <import>gatk_macros.xml</import>
  </macros>
  <command interpreter="python">gatk3_wrapper.py
   ##--max_jvm_heap &quot;128g&quot;
   --max_jvm_heap_fraction &quot;1&quot;
   ##--stdout &quot;${output_log}&quot;
   #for $i, $input_bam in enumerate( $reference_source.input_bams ):
       -d &quot;-I&quot; &quot;${input_bam.input_bam}&quot; &quot;${input_bam.input_bam.ext}&quot; &quot;gatk_input_${i}&quot;
       #if str( $input_bam.input_bam.metadata.bam_index ) != &quot;None&quot;:
           -d &quot;&quot; &quot;${input_bam.input_bam.metadata.bam_index}&quot; &quot;bam_index&quot; &quot;gatk_input_${i}&quot; ##hardcode galaxy ext type as bam_index
       #end if
   #end for
   -p 'java 
    -jar &quot;\$GATK3_PATH/GenomeAnalysisTK.jar&quot;
    -T &quot;DepthOfCoverage&quot;
    \$GATK3_SITE_OPTIONS
    ## \$GATK3_NUM_THREADS
    ##--num_threads 32 ##hard coded, for now
    ##-et &quot;NO_ET&quot; -K &quot;/data/galaxy/appList/GenomeAnalysisTK-2.0-36-gf5c1c1a/gatk3_key_file&quot; ##ET no phone home
    #if $reference_source.reference_source_selector != &quot;history&quot;:
        -R &quot;${reference_source.ref_file.fields.path}&quot;
    #end if
    #if str( $input_calculate_coverage_over_genes ) != &quot;None&quot;:
        --calculateCoverageOverGenes &quot;${input_calculate_coverage_over_genes}&quot;
    #end if
    #if str( $partition_type ) != &quot;None&quot;:
        #for $pt in str( $partition_type ).split( ',' ):
            --partitionType &quot;${pt}&quot;
        #end for
    #end if
    --out &quot;${output_per_locus_coverage}&quot;
    
    #for $ct_group in $summary_coverage_threshold_group:
        --summaryCoverageThreshold &quot;${ct_group.summary_coverage_threshold}&quot;
    #end for
    --outputFormat &quot;${output_format}&quot;
   '
   
    ##start standard gatk options
    #if $gatk_param_type.gatk_param_type_selector == &quot;advanced&quot;:
        #include source=$standard_gatk_options#
    #end if
    
    #if $reference_source.reference_source_selector == &quot;history&quot;:
        -d &quot;-R&quot; &quot;${reference_source.ref_file}&quot; &quot;${reference_source.ref_file.ext}&quot; &quot;gatk_input_reference_fasta&quot;
        --picard_jar &quot;/mnt/galaxyTools/tools/picard/1.121/CreateSequenceDictionary.jar&quot;
    #end if
    ##end standard gatk options
    ##start analysis specific options
    #if $analysis_param_type.analysis_param_type_selector == &quot;advanced&quot;:
        -p '
        ${analysis_param_type.ignore_deletion_sites}
        ${analysis_param_type.include_deletions}
        #if str( $analysis_param_type.max_base_quality ) != &quot;127&quot;:
          --maxBaseQuality &quot;${analysis_param_type.max_base_quality}&quot;
        #end if
        #if str( $analysis_param_type.max_mapping_quality ) != &quot;2147483647&quot;:
          --maxMappingQuality &quot;${analysis_param_type.max_mapping_quality}&quot;
        #end if
        #if str( $analysis_param_type.min_base_quality ) != &quot;-1&quot;:
          --minBaseQuality &quot;${analysis_param_type.min_base_quality}&quot;
        #end if
        #if str( $analysis_param_type.min_mapping_quality ) != &quot;-1&quot;:
          --minMappingQuality &quot;${analysis_param_type.min_mapping_quality}&quot;
        #end if
        #if str( $analysis_param_type.n_bins ) != &quot;499&quot;:
          --nBins &quot;${analysis_param_type.n_bins}&quot;
        #end if
        ${analysis_param_type.omit_depth_output_at_each_base}
        ${analysis_param_type.omit_interval_statistics}
        ${analysis_param_type.omit_locus_table}
        ${analysis_param_type.omit_per_sample_stats}
        ${analysis_param_type.print_base_counts}
        ${analysis_param_type.print_bin_endpoints_and_exit}
        #if str( $analysis_param_type.start ) != &quot;1&quot;:
          --start &quot;${analysis_param_type.start}&quot;
        #end if
        #if str( $analysis_param_type.stop ) != &quot;500&quot;:
          --stop &quot;${analysis_param_type.stop}&quot;
        #end if
        '
    #end if
    ##Move additional files to final location
    #if str( $partition_type ) != &quot;None&quot;:
       #set $partition_types = str( $partition_type ).split( ',' )
    #else:
        #set $partition_types = [ 'sample' ]
    #end if
    #if 'sample' in $partition_types and ( str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.print_bin_endpoints_and_exit ) == &quot;&quot; ):
        #if str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_per_sample_stats ) == &quot;&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.sample_summary ${output_summary_sample}
            &amp;&amp; mv ${output_per_locus_coverage}.sample_statistics ${output_statistics_sample}
        #end if
        #if $gatk_param_type.gatk_param_type_selector == &quot;advanced&quot; and len( $gatk_param_type.input_interval_repeat ) and ( str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_interval_statistics ) == &quot;&quot; ):
            &amp;&amp; mv ${output_per_locus_coverage}.sample_interval_summary ${output_interval_summary_sample}
            &amp;&amp; mv ${output_per_locus_coverage}.sample_interval_statistics ${output_interval_statistics_sample}
        #end if
        #if str( $input_calculate_coverage_over_genes ) != &quot;None&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.sample_gene_summary ${output_gene_summary_sample}
        #end if
        #if str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_depth_output_at_each_base ) == &quot;&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.sample_cumulative_coverage_counts ${output_cumulative_coverage_counts_sample}
            &amp;&amp; mv ${output_per_locus_coverage}.sample_cumulative_coverage_proportions ${output_cumulative_coverage_proportions_sample}
        #end if
    #end if
    
    #if 'readgroup' in $partition_types and ( str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.print_bin_endpoints_and_exit ) == &quot;&quot; ):
        #if str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_per_sample_stats ) == &quot;&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.read_group_summary ${output_summary_readgroup}
            &amp;&amp; mv ${output_per_locus_coverage}.read_group_statistics ${output_statistics_readgroup}
        #end if
        #if $gatk_param_type.gatk_param_type_selector == &quot;advanced&quot; and len( $gatk_param_type.input_interval_repeat ) and ( str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_interval_statistics ) == &quot;&quot; ):
            &amp;&amp; mv ${output_per_locus_coverage}.read_group_interval_summary ${output_interval_summary_readgroup}
            &amp;&amp; mv ${output_per_locus_coverage}.read_group_interval_statistics ${output_interval_statistics_readgroup}
        #end if
        #if str( $input_calculate_coverage_over_genes ) != &quot;None&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.read_group_gene_summary ${output_gene_summary_readgroup}
        #end if
        #if str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_depth_output_at_each_base ) == &quot;&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.read_group_cumulative_coverage_counts ${output_cumulative_coverage_counts_readgroup}
            &amp;&amp; mv ${output_per_locus_coverage}.read_group_cumulative_coverage_proportions ${output_cumulative_coverage_proportions_readgroup}
        #end if
    #end if
    
    #if 'library' in $partition_types and ( str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.print_bin_endpoints_and_exit ) == &quot;&quot; ):
        #if str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_per_sample_stats ) == &quot;&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.library_summary ${output_summary_library}
            &amp;&amp; mv ${output_per_locus_coverage}.library_statistics ${output_statistics_library}
        #end if
        #if $gatk_param_type.gatk_param_type_selector == &quot;advanced&quot; and len( $gatk_param_type.input_interval_repeat ) and ( str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_interval_statistics ) == &quot;&quot; ):
            &amp;&amp; mv ${output_per_locus_coverage}.library_interval_summary ${output_interval_summary_library}
            &amp;&amp; mv ${output_per_locus_coverage}.library_interval_statistics ${output_interval_statistics_library}
        #end if
        #if str( $input_calculate_coverage_over_genes ) != &quot;None&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.library_gene_summary ${output_gene_summary_library}
        #end if
        #if str( $analysis_param_type.analysis_param_type_selector ) == &quot;basic&quot; or str( $analysis_param_type.omit_depth_output_at_each_base ) == &quot;&quot;:
            &amp;&amp; mv ${output_per_locus_coverage}.library_cumulative_coverage_counts ${output_cumulative_coverage_counts_library}
            &amp;&amp; mv ${output_per_locus_coverage}.library_cumulative_coverage_proportions ${output_cumulative_coverage_proportions_library}
        #end if
    #end if
    

  </command>
  <inputs>
    <conditional name="reference_source">
      <param label="Choose the source for the reference list" name="reference_source_selector" type="select">
        <option value="cached">Locally cached</option>
        <option value="history">History</option>
      </param>
      <when value="cached">
        <repeat help="-I,--input_file &amp;lt;input_file&amp;gt;" min="1" name="input_bams" title="BAM file">
            <param format="bam" label="BAM file" name="input_bam" type="data">
              <validator type="unspecified_build"/>
              <validator message="Sequences are not currently available for the specified build." metadata_column="dbkey" metadata_name="dbkey" table_name="gatk3_picard_indexes" type="dataset_metadata_in_data_table"/> <!-- fixme!!! this needs to be a select -->
            </param>
        </repeat>
        <param help="-R,--reference_sequence &amp;lt;reference_sequence&amp;gt;" label="Using reference genome" name="ref_file" type="select">
          <options from_data_table="gatk3_picard_indexes">
            <!-- <filter type="data_meta" key="dbkey" ref="input_bam" column="dbkey"/> does not yet work in a repeat...--> 
          </options>
          <validator message="A built-in reference genome is not available for the build associated with the selected input file" type="no_options"/>
        </param>
      </when>
      <when value="history"> <!-- FIX ME!!!! -->
        <repeat help="-I,--input_file &amp;lt;input_file&amp;gt;" min="1" name="input_bams" title="BAM file">
            <param format="bam" label="BAM file" name="input_bam" type="data"/>
        </repeat>
        <param format="fasta" help="-R,--reference_sequence &amp;lt;reference_sequence&amp;gt;" label="Using reference file" name="ref_file" type="data"/>
      </when>
    </conditional>
    
    <param format="data" help="-geneList,--calculateCoverageOverGenes &amp;lt;calculateCoverageOverGenes&amp;gt;" label="RefSeq Rod" name="input_calculate_coverage_over_genes" optional="True" type="data"/>
    
    <param display="checkboxes" help="-pt,--partitionType &amp;lt;partitionType&amp;gt;" label="Partition type for depth of coverage" multiple="True" name="partition_type" type="select">
      <option selected="True" value="sample">sample</option>
      <option value="readgroup">readgroup</option>
      <option value="library">library</option>
    </param>
    
    <repeat help="-ct,--summaryCoverageThreshold &amp;lt;summaryCoverageThreshold&amp;gt;" name="summary_coverage_threshold_group" title="Summary coverage threshold">
        <param label="for summary file outputs, report the % of bases covered to &gt;= this number" name="summary_coverage_threshold" type="integer" value="15"/>
    </repeat>
    
    <param help="--outputFormat &amp;lt;outputFormat&amp;gt;" label="Output format" name="output_format" type="select">
      <option value="csv">csv</option>
      <option value="table">table</option>
      <option selected="True" value="rtable">rtable</option>
    </param>
    
    <conditional name="gatk_param_type">
      <param label="Basic or Advanced GATK options" name="gatk_param_type_selector" type="select">
        <option selected="True" value="basic">Basic</option>
        <option value="advanced">Advanced</option>
      </param>
      <when value="basic">
        <!-- Do nothing here -->
      </when>
      <when value="advanced">
        <expand macro="advanced_options" />
      </when>
    </conditional>
    
    <conditional name="analysis_param_type">
      <param label="Basic or Advanced Analysis options" name="analysis_param_type_selector" type="select">
        <option selected="True" value="basic">Basic</option>
        <option value="advanced">Advanced</option>
      </param>
      <when value="basic">
        <!-- Do nothing here -->
      </when>
      <when value="advanced">
        <param checked="False" falsevalue="" help="--ignoreDeletionSites" label="Ignore sites consisting only of deletions" name="ignore_deletion_sites" truevalue="--ignoreDeletionSites" type="boolean"/>
        <param checked="False" falsevalue="" help="-dels,--includeDeletions" label="Include information on deletions" name="include_deletions" truevalue="--includeDeletions" type="boolean"/>
        <param help="--maxBaseQuality &amp;lt;maxBaseQuality&amp;gt;" label="Maximum quality of bases to count towards depth" name="max_base_quality" type="integer" value="127"/>
        <param help="-mbq,--minBaseQuality &amp;lt;minBaseQuality&amp;gt;This is set to -1 by default to disable the evaluation and ignore this threshold." label="Minimum quality of bases to count towards depth" name="min_base_quality" type="integer" value="-1"/>
        <param help="--maxMappingQuality &amp;lt;maxMappingQuality&amp;gt;" label="Maximum mapping quality of reads to count towards depth." name="max_mapping_quality" type="integer" value="2147483647"/>
        <param help="-mmq,--minMappingQuality &amp;lt;minMappingQuality&amp;gt;This is set to -1 by default to disable the evaluation and ignore this threshold." label="Minimum mapping quality of reads to count towards depth" name="min_mapping_quality" type="integer" value="-1"/>
        <param help="--nBins &amp;lt;nBins&amp;gt;" label="Number of bins to use for granular binning" name="n_bins" type="integer" value="499"/>
        <param checked="False" falsevalue="" help="-omitBaseOutput,--omitDepthOutputAtEachBase" label="Omit the output of the depth of coverage at each base" name="omit_depth_output_at_each_base" truevalue="--omitDepthOutputAtEachBase" type="boolean"/>
        <param checked="False" falsevalue="" help="-omitIntervals,--omitIntervalStatistics" label="Omit the per-interval statistics section" name="omit_interval_statistics" truevalue="--omitIntervalStatistics" type="boolean"/>
        <param checked="False" falsevalue="" help="-omitLocusTable,--omitLocusTable" label="Do not calculate the per-sample per-depth counts of loci" name="omit_locus_table" truevalue="--omitLocusTable" type="boolean"/>
        <param checked="False" falsevalue="" help="-omitSampleSummary,--omitPerSampleStats" label="Omit the summary files per-sample." name="omit_per_sample_stats" truevalue="--omitPerSampleStats" type="boolean"/>
        <param checked="False" falsevalue="" help="-baseCounts,--printBaseCounts" label="Add base counts to per-locus output" name="print_base_counts" truevalue="--printBaseCounts" type="boolean"/>
        <param checked="False" falsevalue="" help="--printBinEndpointsAndExit" label="Print the bin values and exits immediately" name="print_bin_endpoints_and_exit" truevalue="--printBinEndpointsAndExit" type="boolean"/>
        <param help="--start &amp;lt;start&amp;gt;" label="Starting (left endpoint) for granular binning" name="start" type="integer" value="1"/>
        <param help="--stop &amp;lt;stop&amp;gt;" label="Ending (right endpoint) for granular binning" name="stop" type="integer" value="500"/>
      </when>
    </conditional>
  </inputs>
  <outputs>
    <data format="tabular" label="${tool.name} on ${on_string} (per locus coverage)" name="output_per_locus_coverage">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output summary sample)" name="output_summary_sample">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_per_sample_stats'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'sample' in partition_type or not partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output statistics sample)" name="output_statistics_sample">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_per_sample_stats'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'sample' in partition_type or not partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output interval summary sample)" name="output_interval_summary_sample">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'sample' in partition_type or not partition_type</filter>
        <filter>gatk_param_type['gatk_param_type_selector'] == &quot;advanced&quot; and len( gatk_param_type['input_interval_repeat'] )</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_interval_statistics'] == False</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output interval statistics sample)" name="output_interval_statistics_sample">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'sample' in partition_type or not partition_type</filter>
        <filter>gatk_param_type['gatk_param_type_selector'] == &quot;advanced&quot; and len( gatk_param_type['input_interval_repeat'] )</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_interval_statistics'] == False</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output gene summary sample)" name="output_gene_summary_sample">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>input_calculate_coverage_over_genes is not None and 'sample' in partition_type or not partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output cumulative coverage counts sample)" name="output_cumulative_coverage_counts_sample">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_depth_output_at_each_base'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'sample' in partition_type or not partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output cumulative coverage proportions sample)" name="output_cumulative_coverage_proportions_sample">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_depth_output_at_each_base'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'sample' in partition_type or not partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    
    <data format="tabular" label="${tool.name} on ${on_string} (output summary readgroup)" name="output_summary_readgroup">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_per_sample_stats'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'readgroup' in partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output statistics readgroup)" name="output_statistics_readgroup">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_per_sample_stats'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'readgroup' in partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output interval summary readgroup)" name="output_interval_summary_readgroup">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'readgroup' in partition_type</filter>
        <filter>gatk_param_type['gatk_param_type_selector'] == &quot;advanced&quot; and len( gatk_param_type['input_interval_repeat'] )</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_interval_statistics'] == False</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output interval statistics readgroup)" name="output_interval_statistics_readgroup">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'readgroup' in partition_type</filter>
        <filter>gatk_param_type['gatk_param_type_selector'] == &quot;advanced&quot; and len( gatk_param_type['input_interval_repeat'] )</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_interval_statistics'] == False</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output gene summary readgroup)" name="output_gene_summary_readgroup">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>input_calculate_coverage_over_genes is not None and 'readgroup' in partition_type or not partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output cumulative coverage counts readgroup)" name="output_cumulative_coverage_counts_readgroup">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_depth_output_at_each_base'] == False</filter>
        <filter>'readgroup' in partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output cumulative coverage proportions readgroup)" name="output_cumulative_coverage_proportions_readgroup">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_depth_output_at_each_base'] == False</filter>
        <filter>'readgroup' in partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    
    <data format="tabular" label="${tool.name} on ${on_string} (output summary library)" name="output_summary_library">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_per_sample_stats'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'library' in partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output statistics library)" name="output_statistics_library">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_per_sample_stats'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'library' in partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output interval summary library)" name="output_interval_summary_library">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'library' in partition_type</filter>
        <filter>gatk_param_type['gatk_param_type_selector'] == &quot;advanced&quot; and len( gatk_param_type['input_interval_repeat'] )</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_interval_statistics'] == False</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output interval statistics library)" name="output_interval_statistics_library">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'library' in partition_type</filter>
        <filter>gatk_param_type['gatk_param_type_selector'] == &quot;advanced&quot; and len( gatk_param_type['input_interval_repeat'] )</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_interval_statistics'] == False</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output gene summary library)" name="output_gene_summary_library">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>input_calculate_coverage_over_genes is not None and 'library' in partition_type or not partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output cumulative coverage counts library)" name="output_cumulative_coverage_counts_library">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_depth_output_at_each_base'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'library' in partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    <data format="tabular" label="${tool.name} on ${on_string} (output cumulative coverage proportions library)" name="output_cumulative_coverage_proportions_library">
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['omit_depth_output_at_each_base'] == False</filter>
        <filter>analysis_param_type['analysis_param_type_selector'] == &quot;basic&quot; or analysis_param_type['print_bin_endpoints_and_exit'] == False</filter>
        <filter>'library' in partition_type</filter>
        <actions>
            <conditional name="output_format">
                <when value="rtable">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
                <when value="csv">
                    <action type="format">
                        <option name="output_format" type="from_param"/>
                    </action>
                </when>
            </conditional>
        </actions>
    </data>
    
  </outputs>
  <trackster_conf/>
  <tests>
      <test>
          <param name="reference_source_selector" value="history"/>
          <param ftype="fasta" name="ref_file" value="phiX.fasta"/>
          <param ftype="bam" name="input_bam" value="gatk/gatk_table_recalibration/gatk_table_recalibration_out_1.bam"/>
          <param name="input_calculate_coverage_over_genes"/>
          <param name="partition_type" value="sample"/>
          <param name="summary_coverage_threshold_group" value="0"/>
          <param name="output_format" value="rtable"/>
          <param name="gatk_param_type_selector" value="basic"/>
          <param name="analysis_param_type_selector" value="basic"/>
          <output file="gatk/gatk_depth_of_coverage/gatk_depth_of_coverage_out_1_output_per_locus_coverage.tabular" name="output_per_locus_coverage"/>
          <output file="gatk/gatk_depth_of_coverage/gatk_depth_of_coverage_out_1_output_summary_sample.tabular" name="output_summary_sample"/>
          <output file="gatk/gatk_depth_of_coverage/gatk_depth_of_coverage_out_1_output_statistics_sample.tabular" name="output_statistics_sample"/>
          <output file="gatk/gatk_depth_of_coverage/gatk_depth_of_coverage_out_1_output_cumulative_coverage_counts_sample.tabular" name="output_cumulative_coverage_counts_sample"/>
          <output file="gatk/gatk_depth_of_coverage/gatk_depth_of_coverage_out_1_output_output_cumulative_coverage_proportions_sample.tabular" name="output_cumulative_coverage_proportions_sample"/>
          <output compare="contains" file="gatk/gatk_depth_of_coverage/gatk_depth_of_coverage_out_1.log.contains" name="output_log"/>
      </test>
  </tests>
  <help>
**What it does**

DepthOfCoverage processes a set of bam files to determine coverage at different levels of partitioning and aggregation. Coverage can be analyzed per locus, per interval, per gene, or in total; can be partitioned by sample, by read group, by technology, by center, or by library; and can be summarized by mean, median, quartiles, and/or percentage of bases covered to or beyond a threshold. Additionally, reads and bases can be filtered by mapping or base quality score. 

For more information on the GATK Depth of Coverage, see this `tool specific page &lt;http://www.broadinstitute.org/gatk/gatkdocs/org_broadinstitute_sting_gatk_walkers_annotator_DepthOfCoverage.html&gt;`_.

To learn about best practices for variant detection using GATK, see this `overview &lt;http://www.broadinstitute.org/gatk/guide/topic?name=best-practices&gt;`_.

If you encounter errors, please view the `GATK FAQ &lt;http://www.broadinstitute.org/gatk/guide/topic?name=faqs&gt;`_.

------

**Inputs**

GenomeAnalysisTK: DepthOfCoverage accepts aligned BAM input files.


**Outputs**

The output is in various table formats.


Go `here &lt;http://www.broadinstitute.org/gatk/guide/topic?name=intro&gt;`_ for details on GATK file formats.

-------

**Settings**::

 calculateCoverageOverGenes     File     NA     Calculate the coverage statistics over this list of genes. Currently accepts RefSeq.
 ignoreDeletionSites     boolean     false     Ignore sites consisting only of deletions
 includeDeletions     boolean     false     Include information on deletions
 maxBaseQuality     byte     127     Maximum quality of bases to count towards depth. Defaults to 127 (Byte.MAX_VALUE).
 maxMappingQuality     int     2147483647     Maximum mapping quality of reads to count towards depth. Defaults to 2^31-1 (Integer.MAX_VALUE).
 minBaseQuality     byte     -1     Minimum quality of bases to count towards depth. Defaults to -1.
 minMappingQuality     int     -1     Minimum mapping quality of reads to count towards depth. Defaults to -1.
 nBins     int     499     Number of bins to use for granular binning
 omitDepthOutputAtEachBase     boolean     false     Will omit the output of the depth of coverage at each base, which should result in speedup
 omitIntervalStatistics     boolean     false     Will omit the per-interval statistics section, which should result in speedup
 omitLocusTable     boolean     false     Will not calculate the per-sample per-depth counts of loci, which should result in speedup
 omitPerSampleStats     boolean     false     Omits the summary files per-sample. These statistics are still calculated, so this argument will not improve runtime.
 outputFormat     String     rtable     the format of the output file (e.g. csv, table, rtable); defaults to r-readable table
 partitionType     Set[Partition]     [sample]     Partition type for depth of coverage. Defaults to sample. Can be any combination of sample, readgroup, library.
 printBaseCounts     boolean     false     Will add base counts to per-locus output.
 printBinEndpointsAndExit     boolean     false     Prints the bin values and exits immediately. Use to calibrate what bins you want before running on data.
 start     int     1     Starting (left endpoint) for granular binning
 stop     int     500     Ending (right endpoint) for granular binning
 summaryCoverageThreshold     int[]     [15]     for summary file outputs, report the % of bases coverd to &gt;= this number. Defaults to 15; can take multiple arguments.

------

**Citation**

For the underlying tool, please cite `DePristo MA, Banks E, Poplin R, Garimella KV, Maguire JR, Hartl C, Philippakis AA, del Angel G, Rivas MA, Hanna M, McKenna A, Fennell TJ, Kernytsky AM, Sivachenko AY, Cibulskis K, Gabriel SB, Altshuler D, Daly MJ. A framework for variation discovery and genotyping using next-generation DNA sequencing data. Nat Genet. 2011 May;43(5):491-8. &lt;http://www.ncbi.nlm.nih.gov/pubmed/21478889&gt;`_

Please also site `McKenna A, Hanna M, Banks E, Sivachenko A, Cibulskis K, Kernytsky A, Garimella K, Altshuler D, Gabriel S, Daly M, DePristo MA (2010). The Genome Analysis Toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data. Genome Res. 20:1297-303. Epub 2010 Jul 19. &lt;http://www.ncbi.nlm.nih.gov/pubmed/20644199&gt;`_

If you use this tool in Galaxy, please cite `Blankenberg D, Von Kuster G, Coraor N, Ananda G, Lazarus R, Mangan M, Nekrutenko A, Taylor J. Galaxy: a web-based genome analysis tool for experimentalists. Curr Protoc Mol Biol. 2010 Jan;Chapter 19:Unit 19.10.1-21. &lt;http://www.ncbi.nlm.nih.gov/pubmed/20069535&gt;`_

  </help>
</tool>
