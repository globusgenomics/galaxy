<tool id="tophat" name="Tophat for Illumina" version="TOPHAT: 1.4.1; SAMTOOLS: 0.1.19">
    <!-- Wrapper compatible with Tophat versions 1.3.0 to 1.4.1 -->
    <description>Find splice junctions using RNA-seq data</description>
    <version_command>tophat --version</version_command>
    <requirements>
        <requirement type="package">tophat</requirement>
        <requirement type="package" version="0.1.19">samtools</requirement>
    </requirements>
    <command interpreter="python">
        tophat_wrapper.py
            ## Change this to accommodate the number of threads you have available.
            --num-threads=&quot;4&quot;

            ## Provide outputs.
            --junctions-output=$junctions
            --hits-output=$accepted_hits

            ## Handle reference file.
            #if $refGenomeSource.genomeSource == &quot;history&quot;:
                --own-file=$refGenomeSource.ownFile
            #else:
                --indexes-path=&quot;${refGenomeSource.index.fields.path}&quot;
            #end if

            ## Are reads single-end or paired?
            --single-paired=$singlePaired.sPaired

            ## First input file always required.
            --input1=$input1

            ## Set params based on whether reads are single-end or paired.
            #if $singlePaired.sPaired == &quot;single&quot;:
                --settings=$singlePaired.sParams.sSettingsType
                #if $singlePaired.sParams.sSettingsType == &quot;full&quot;:
                    -a $singlePaired.sParams.anchor_length
                    -m $singlePaired.sParams.splice_mismatches
                    -i $singlePaired.sParams.min_intron_length
                    -I $singlePaired.sParams.max_intron_length
                    -g $singlePaired.sParams.max_multihits
                    --min-segment-intron $singlePaired.sParams.min_segment_intron
                    --max-segment-intron $singlePaired.sParams.max_segment_intron
                    --initial-read-mismatches=$singlePaired.sParams.initial_read_mismatches
                    --seg-mismatches=$singlePaired.sParams.seg_mismatches
                    --seg-length=$singlePaired.sParams.seg_length
                    --library-type=$singlePaired.sParams.library_type
                    
                    ## Indel search.
                    #if $singlePaired.sParams.indel_search.allow_indel_search == &quot;Yes&quot;:
                        ## --allow-indels
                        --max-insertion-length $singlePaired.sParams.indel_search.max_insertion_length
                        --max-deletion-length $singlePaired.sParams.indel_search.max_deletion_length
                    #else:
                        --no-novel-indels
                    #end if

                    ## Supplying junctions parameters.
                    #if $singlePaired.sParams.own_junctions.use_junctions == &quot;Yes&quot;:
                        #if $singlePaired.sParams.own_junctions.gene_model_ann.use_annotations == &quot;Yes&quot;:
                            -G $singlePaired.sParams.own_junctions.gene_model_ann.gene_annotation_model
                        #end if
                        #if $singlePaired.sParams.own_junctions.raw_juncs.use_juncs == &quot;Yes&quot;:
                            -j $singlePaired.sParams.own_junctions.raw_juncs.raw_juncs
                        #end if
                        ## TODO: No idea why a string cast is necessary, but it is:
                        #if str($singlePaired.sParams.own_junctions.no_novel_juncs) == &quot;Yes&quot;:
                            --no-novel-juncs
                        #end if
                    #end if

                    #if $singlePaired.sParams.closure_search.use_search == &quot;Yes&quot;:
                        --closure-search
                        --min-closure-exon $singlePaired.sParams.closure_search.min_closure_exon
                        --min-closure-intron $singlePaired.sParams.closure_search.min_closure_intron
                        --max-closure-intron $singlePaired.sParams.closure_search.max_closure_intron
                    #else:
                        --no-closure-search
                    #end if
                    #if $singlePaired.sParams.coverage_search.use_search == &quot;Yes&quot;:
                        --coverage-search
                        --min-coverage-intron $singlePaired.sParams.coverage_search.min_coverage_intron
                        --max-coverage-intron $singlePaired.sParams.coverage_search.max_coverage_intron
                    #else:
                        --no-coverage-search
                    #end if
                    ## TODO: No idea why the type conversion is necessary, but it seems to be.
                    #if str($singlePaired.sParams.microexon_search) == &quot;Yes&quot;:
                        --microexon-search
                    #end if
                #end if
            #else:
                --input2=$singlePaired.input2
                -r $singlePaired.mate_inner_distance
                --settings=$singlePaired.pParams.pSettingsType
                #if $singlePaired.pParams.pSettingsType == &quot;full&quot;:
                    --mate-std-dev=$singlePaired.pParams.mate_std_dev
                    -a $singlePaired.pParams.anchor_length
                    -m $singlePaired.pParams.splice_mismatches
                    -i $singlePaired.pParams.min_intron_length
                    -I $singlePaired.pParams.max_intron_length
                    -g $singlePaired.pParams.max_multihits
                    --min-segment-intron $singlePaired.pParams.min_segment_intron
                    --max-segment-intron $singlePaired.pParams.max_segment_intron
                    --initial-read-mismatches=$singlePaired.pParams.initial_read_mismatches
                    --seg-mismatches=$singlePaired.pParams.seg_mismatches
                    --seg-length=$singlePaired.pParams.seg_length
                    --library-type=$singlePaired.pParams.library_type
                    
                    ## Indel search.
                    #if $singlePaired.pParams.indel_search.allow_indel_search == &quot;Yes&quot;:
                        ## --allow-indels
                        --max-insertion-length $singlePaired.pParams.indel_search.max_insertion_length
                        --max-deletion-length $singlePaired.pParams.indel_search.max_deletion_length
                    #else:
                        --no-novel-indels
                    #end if

                    ## Supplying junctions parameters.
                    #if $singlePaired.pParams.own_junctions.use_junctions == &quot;Yes&quot;:
                        #if $singlePaired.pParams.own_junctions.gene_model_ann.use_annotations == &quot;Yes&quot;:
                            -G $singlePaired.pParams.own_junctions.gene_model_ann.gene_annotation_model
                        #end if
                        #if $singlePaired.pParams.own_junctions.raw_juncs.use_juncs == &quot;Yes&quot;:
                            -j $singlePaired.pParams.own_junctions.raw_juncs.raw_juncs
                        #end if
                        ## TODO: No idea why type cast is necessary, but it is:
                        #if str($singlePaired.pParams.own_junctions.no_novel_juncs) == &quot;Yes&quot;:
                            --no-novel-juncs
                        #end if
                    #end if

                    #if $singlePaired.pParams.closure_search.use_search == &quot;Yes&quot;:
                        --closure-search
                        --min-closure-exon $singlePaired.pParams.closure_search.min_closure_exon
                        --min-closure-intron $singlePaired.pParams.closure_search.min_closure_intron
                        --max-closure-intron $singlePaired.pParams.closure_search.max_closure_intron
                    #else:
                        --no-closure-search
                    #end if
                    #if $singlePaired.pParams.coverage_search.use_search == &quot;Yes&quot;:
                        --coverage-search
                        --min-coverage-intron $singlePaired.pParams.coverage_search.min_coverage_intron
                        --max-coverage-intron $singlePaired.pParams.coverage_search.max_coverage_intron
                    #else:
                        --no-coverage-search
                    #end if
                    ## TODO: No idea why the type conversion is necessary, but it seems to be.
                    #if str ($singlePaired.pParams.microexon_search) == &quot;Yes&quot;:
                        --microexon-search
                   #end if
                #end if
            #end if
    </command>
    <inputs>
        <param format="fastqsanger" help="Nucleotide-space: Must have Sanger-scaled quality values with ASCII offset 33" label="RNA-Seq FASTQ file" name="input1" type="data"/>
        <conditional name="refGenomeSource">
          <param help="Built-ins genomes were created using default options" label="Use a built in reference genome or own from your history" name="genomeSource" type="select">
            <option selected="True" value="indexed">Use a built-in genome</option>
            <option value="history">Use a genome from history</option>
          </param>
          <when value="indexed">
            <param help="If your genome of interest is not listed, contact the Galaxy team" label="Select a reference genome" name="index" type="select">
              <options from_data_table="tophat_indexes">
                <filter column="2" type="sort_by"/>
                <validator message="No genomes are available for the selected input dataset" type="no_options"/>
              </options>
            </param>
          </when>
          <when value="history">
            <param format="fasta" label="Select the reference genome" metadata_name="dbkey" name="ownFile" type="data"/>
          </when>  <!-- history -->
        </conditional>  <!-- refGenomeSource -->
        <conditional name="singlePaired">
            <param label="Is this library mate-paired?" name="sPaired" type="select">
              <option value="single">Single-end</option>
              <option value="paired">Paired-end</option>
            </param>
            <when value="single">
              <conditional name="sParams">
                <param help="Use the Full parameter list to change default settings." label="TopHat settings to use" name="sSettingsType" type="select">
                  <option value="preSet">Default settings</option>
                  <option value="full">Full parameter list</option>
                </param>
                <when value="preSet"/>
                <!-- Full/advanced params. -->
                <when value="full">
                  <param help="TopHat will treat the reads as strand specific. Every read alignment will have an XS attribute tag. Consider supplying library type options below to select the correct RNA-seq protocol." label="Library Type" name="library_type" type="select">
                      <option value="fr-unstranded">FR Unstranded</option>
                      <option value="fr-firststrand">FR First Strand</option>
                      <option value="fr-secondstrand">FR Second Strand</option>
                  </param>
                  <param help="Report junctions spanned by reads with at least this many bases on each side of the junction." label="Anchor length (at least 3)" name="anchor_length" type="integer" value="8"/>
                  <param label="Maximum number of mismatches that can appear in the anchor region of spliced alignment" name="splice_mismatches" type="integer" value="0"/>
                  <param help="TopHat will ignore donor/acceptor pairs closer than this many bases apart." label="The minimum intron length" name="min_intron_length" type="integer" value="70"/>
                  <param help="When searching for junctions ab initio, TopHat will ignore donor/acceptor pairs farther than this many bases apart, except when such a pair is supported by a split segment alignment of a long read." label="The maximum intron length" name="max_intron_length" type="integer" value="500000"/>
                  <conditional name="indel_search">
                      <param label="Allow indel search" name="allow_indel_search" type="select">
                          <option value="Yes">Yes</option>
                          <option value="No">No</option>
                      </param>
                      <when value="No"/>
                      <when value="Yes">
                         <param help="The maximum insertion length." label="Max insertion length." name="max_insertion_length" type="integer" value="3"/>
                         <param help="The maximum deletion length." label="Max deletion length." name="max_deletion_length" type="integer" value="3"/>
                      </when>
                  </conditional>
alignments (number of reads divided by average depth of coverage)&quot; help=&quot;0.0 to 1.0 (0 to turn off)&quot; /&gt;
                  <param label="Maximum number of alignments to be allowed" name="max_multihits" type="integer" value="20"/>
                  <param label="Minimum intron length that may be found during split-segment (default) search" name="min_segment_intron" type="integer" value="50"/>
                  <param label="Maximum intron length that may be found during split-segment (default) search" name="max_segment_intron" type="integer" value="500000"/>
                  <param label="Number of mismatches allowed in the initial read mapping" min="0" name="initial_read_mismatches" type="integer" value="2"/>
                  <param label="Number of mismatches allowed in each segment alignment for reads mapped independently" max="3" min="0" name="seg_mismatches" type="integer" value="2"/>
                  <param label="Minimum length of read segments" name="seg_length" type="integer" value="25"/>
                  
                  <!-- Options for supplying own junctions. -->
                  <conditional name="own_junctions">
                      <param label="Use Own Junctions" name="use_junctions" type="select">
                        <option value="No">No</option>
                        <option value="Yes">Yes</option>
                      </param>
                      <when value="Yes">
                          <conditional name="gene_model_ann">
                             <param label="Use Gene Annotation Model" name="use_annotations" type="select">
                                <option value="No">No</option>
                                <option value="Yes">Yes</option>
                             </param>
                             <when value="No"/>
                             <when value="Yes">
                               <param format="gtf,gff3" help="TopHat will use the exon records in this file to build a set of known splice junctions for each gene, and will attempt to align reads to these junctions even if they would not normally be covered by the initial mapping." label="Gene Model Annotations" name="gene_annotation_model" type="data"/>
                             </when>
                          </conditional>
                          <conditional name="raw_juncs">
                             <param label="Use Raw Junctions" name="use_juncs" type="select">
                                <option value="No">No</option>
                                <option value="Yes">Yes</option>
                             </param>
                             <when value="No"/>
                             <when value="Yes">
                               <param format="interval" help="Supply TopHat with a list of raw junctions. Junctions are specified one per line, in a tab-delimited format. Records look like: [chrom] [left] [right] [+/-] left and right are zero-based coordinates, and specify the last character of the left sequenced to be spliced to the first character of the right sequence, inclusive." label="Raw Junctions" name="raw_juncs" type="data"/>
                             </when>
                          </conditional>
                          <param label="Only look for supplied junctions" name="no_novel_juncs" type="select">
                            <option value="No">No</option>
                            <option value="Yes">Yes</option>
                          </param>
                      </when>
                      <when value="No"/>
                  </conditional> <!-- /own_junctions -->
                  
                  <!-- Closure search. -->
                  <conditional name="closure_search">
                    <param label="Use Closure Search" name="use_search" type="select">
                      <option value="No">No</option>
                      <option value="Yes">Yes</option>
                    </param>
                    <when value="Yes">
                        <param label="During closure search for paired end reads, exonic hops in the potential splice graph must be at least this long. The default is 50." name="min_closure_exon" type="integer" value="50"/>
                        <param label="Minimum intron length that may be found during closure search" name="min_closure_intron" type="integer" value="50"/>
                        <param label="Maximum intron length that may be found during closure search" name="max_closure_intron" type="integer" value="5000"/>
                    </when>
                    <when value="No"/>
                  </conditional>
                  <!-- Coverage search. -->
                  <conditional name="coverage_search">
                    <param label="Use Coverage Search" name="use_search" type="select">
                        <option selected="true" value="Yes">Yes</option>
                        <option value="No">No</option>
                    </param>
                    <when value="Yes">
                        <param label="Minimum intron length that may be found during coverage search" name="min_coverage_intron" type="integer" value="50"/>
                        <param label="Maximum intron length that may be found during coverage search" name="max_coverage_intron" type="integer" value="20000"/>
                    </when>
                    <when value="No"/>
                  </conditional>
                  <param help="With this option, the pipeline will attempt to find alignments incident to microexons. Works only for reads 50bp or longer." label="Use Microexon Search" name="microexon_search" type="select">
                    <option value="No">No</option>
                    <option value="Yes">Yes</option>
                  </param>
                </when>  <!-- full -->
              </conditional>  <!-- sParams -->
            </when>  <!--  single -->
            <when value="paired">
              <param format="fastqsanger" help="Nucleotide-space: Must have Sanger-scaled quality values with ASCII offset 33" label="RNA-Seq FASTQ file" name="input2" type="data"/>
              <param label="Mean Inner Distance between Mate Pairs" name="mate_inner_distance" type="integer" value="20"/>
              <conditional name="pParams">
                <param help="Use the Full parameter list to change default settings." label="TopHat settings to use" name="pSettingsType" type="select">
                  <option value="preSet">Default settings</option>
                  <option value="full">Full parameter list</option>
                </param>
                <when value="preSet"/>
                <!-- Full/advanced params. -->
                <when value="full">
                    <param help="TopHat will treat the reads as strand specific. Every read alignment will have an XS attribute tag. Consider supplying library type options below to select the correct RNA-seq protocol." label="Library Type" name="library_type" type="select">
                        <option value="fr-unstranded">FR Unstranded</option>
                        <option value="fr-firststrand">FR First Strand</option>
                        <option value="fr-secondstrand">FR Second Strand</option>
                    </param>
                    <param help="The standard deviation for the distribution on inner distances between mate pairs." label="Std. Dev for Distance between Mate Pairs" name="mate_std_dev" type="integer" value="20"/>
                  <param help="Report junctions spanned by reads with at least this many bases on each side of the junction." label="Anchor length (at least 3)" name="anchor_length" type="integer" value="8"/>
                  <param label="Maximum number of mismatches that can appear in the anchor region of spliced alignment" name="splice_mismatches" type="integer" value="0"/>
                  <param help="TopHat will ignore donor/acceptor pairs closer than this many bases apart." label="The minimum intron length" name="min_intron_length" type="integer" value="70"/>
                  <param help="When searching for junctions ab initio, TopHat will ignore donor/acceptor pairs farther than this many bases apart, except when such a pair is supported by a split segment alignment of a long read." label="The maximum intron length" name="max_intron_length" type="integer" value="500000"/>
                  <conditional name="indel_search">
                      <param label="Allow indel search" name="allow_indel_search" type="select">
                          <option value="Yes">Yes</option>
                          <option value="No">No</option>
                      </param>
                      <when value="No"/>
                      <when value="Yes">
                         <param help="The maximum insertion length." label="Max insertion length." name="max_insertion_length" type="integer" value="3"/>
                         <param help="The maximum deletion length." label="Max deletion length." name="max_deletion_length" type="integer" value="3"/>
                      </when>
                  </conditional>
                  <param label="Maximum number of alignments to be allowed" name="max_multihits" type="integer" value="20"/>
                  <param label="Minimum intron length that may be found during split-segment (default) search" name="min_segment_intron" type="integer" value="50"/>
                  <param label="Maximum intron length that may be found during split-segment (default) search" name="max_segment_intron" type="integer" value="500000"/>
                  <param label="Number of mismatches allowed in the initial read mapping" min="0" name="initial_read_mismatches" type="integer" value="2"/>
                  <param label="Number of mismatches allowed in each segment alignment for reads mapped independently" max="3" min="0" name="seg_mismatches" type="integer" value="2"/>
                  <param label="Minimum length of read segments" name="seg_length" type="integer" value="25"/>
                  <!-- Options for supplying own junctions. -->
                  <conditional name="own_junctions">
                      <param label="Use Own Junctions" name="use_junctions" type="select">
                        <option value="No">No</option>
                        <option value="Yes">Yes</option>
                      </param>
                      <when value="Yes">
                          <conditional name="gene_model_ann">
                             <param label="Use Gene Annotation Model" name="use_annotations" type="select">
                                <option value="No">No</option>
                                <option value="Yes">Yes</option>
                             </param>
                             <when value="No"/>
                             <when value="Yes">
                               <param format="gtf" help="TopHat will use the exon records in this file to build a set of known splice junctions for each gene, and will attempt to align reads to these junctions even if they would not normally be covered by the initial mapping." label="Gene Model Annotations" name="gene_annotation_model" type="data"/>
                             </when>
                          </conditional>
                          <conditional name="raw_juncs">
                             <param label="Use Raw Junctions" name="use_juncs" type="select">
                                <option value="No">No</option>
                                <option value="Yes">Yes</option>
                             </param>
                             <when value="No"/>
                             <when value="Yes">
                               <param format="interval" help="Supply TopHat with a list of raw junctions. Junctions are specified one per line, in a tab-delimited format. Records look like: [chrom] [left] [right] [+/-] left and right are zero-based coordinates, and specify the last character of the left sequenced to be spliced to the first character of the right sequence, inclusive." label="Raw Junctions" name="raw_juncs" type="data"/>
                             </when>
                          </conditional>
                          <param label="Only look for supplied junctions" name="no_novel_juncs" type="select">
                            <option value="No">No</option>
                            <option value="Yes">Yes</option>
                          </param>
                      </when>
                      <when value="No"/>
                  </conditional> <!-- /own_junctions -->
                  
                  <!-- Closure search. -->
                  <conditional name="closure_search">
                    <param label="Use Closure Search" name="use_search" type="select">
                      <option value="No">No</option>
                      <option value="Yes">Yes</option>
                    </param>
                    <when value="Yes">
                        <param label="During closure search for paired end reads, exonic hops in the potential splice graph must be at least this long. The default is 50." name="min_closure_exon" type="integer" value="50"/>
                        <param label="Minimum intron length that may be found during closure search" name="min_closure_intron" type="integer" value="50"/>
                        <param label="Maximum intron length that may be found during closure search" name="max_closure_intron" type="integer" value="5000"/>
                    </when>
                    <when value="No"/>
                  </conditional>
                  <!-- Coverage search. -->
                  <conditional name="coverage_search">
                    <param label="Use Coverage Search" name="use_search" type="select">
                        <option selected="true" value="Yes">Yes</option>
                        <option value="No">No</option>
                    </param>
                    <when value="Yes">
                        <param label="Minimum intron length that may be found during coverage search" name="min_coverage_intron" type="integer" value="50"/>
                        <param label="Maximum intron length that may be found during coverage search" name="max_coverage_intron" type="integer" value="20000"/>
                    </when>
                    <when value="No"/>
                  </conditional>
                  <param help="With this option, the pipeline will attempt to find alignments incident to microexons. Works only for reads 50bp or longer." label="Use Microexon Search" name="microexon_search" type="select">
                    <option value="No">No</option>
                    <option value="Yes">Yes</option>
                  </param>
                </when>  <!-- full -->
              </conditional>  <!-- pParams -->
            </when>  <!-- paired -->
        </conditional>
    </inputs>

    <outputs>
        <data format="bed" from_work_dir="tophat_out/insertions.bed" label="${tool.name} on ${on_string}: insertions" name="insertions">
            <actions>
              <conditional name="refGenomeSource.genomeSource">
                <when value="indexed">
                  <action name="dbkey" type="metadata">
                    <option column="1" name="tophat_indexes" offset="0" type="from_data_table">
                      <filter column="0" compare="startswith" keep="False" type="param_value" value="#"/>
                      <filter column="0" ref="refGenomeSource.index" type="param_value"/>
                    </option>
                  </action>
                </when>
                <when value="history">
                  <action name="dbkey" type="metadata">
                    <option name="refGenomeSource.ownFile" param_attribute="dbkey" type="from_param"/>
                  </action>
                </when>
              </conditional>
            </actions>
        </data>
        <data format="bed" from_work_dir="tophat_out/deletions.bed" label="${tool.name} on ${on_string}: deletions" name="deletions">
            <actions>
              <conditional name="refGenomeSource.genomeSource">
                <when value="indexed">
                  <action name="dbkey" type="metadata">
                    <option column="1" name="tophat_indexes" offset="0" type="from_data_table">
                      <filter column="0" compare="startswith" keep="False" type="param_value" value="#"/>
                      <filter column="0" ref="refGenomeSource.index" type="param_value"/>
                    </option>
                  </action>
                </when>
                <when value="history">
                  <action name="dbkey" type="metadata">
                    <option name="refGenomeSource.ownFile" param_attribute="dbkey" type="from_param"/>
                  </action>
                </when>
              </conditional>
            </actions>
        </data>
        <data format="bed" from_work_dir="tophat_out/junctions.bed" label="${tool.name} on ${on_string}: splice junctions" name="junctions">
            <actions>
              <conditional name="refGenomeSource.genomeSource">
                <when value="indexed">
                  <action name="dbkey" type="metadata">
                    <option column="1" name="tophat_indexes" offset="0" type="from_data_table">
                      <filter column="0" compare="startswith" keep="False" type="param_value" value="#"/>
                      <filter column="0" ref="refGenomeSource.index" type="param_value"/>
                    </option>
                  </action>
                </when>
                <when value="history">
                  <action name="dbkey" type="metadata">
                    <option name="refGenomeSource.ownFile" param_attribute="dbkey" type="from_param"/>
                  </action>
                </when>
              </conditional>
            </actions>
        </data>
        <data format="bam" from_work_dir="tophat_out/accepted_hits.bam" label="${tool.name} on ${on_string}: accepted_hits" name="accepted_hits">
            <actions>
              <conditional name="refGenomeSource.genomeSource">
                <when value="indexed">
                  <action name="dbkey" type="metadata">
                    <option column="1" name="tophat_indexes" offset="0" type="from_data_table">
                      <filter column="0" compare="startswith" keep="False" type="param_value" value="#"/>
                      <filter column="0" ref="refGenomeSource.index" type="param_value"/>
                    </option>
                  </action>
                </when>
                <when value="history">
                  <action name="dbkey" type="metadata">
                    <option name="refGenomeSource.ownFile" param_attribute="dbkey" type="from_param"/>
                  </action>
                </when>
              </conditional>
            </actions>
        </data>
    </outputs>

    <tests>
        <!-- Test base-space single-end reads with pre-built index and preset parameters -->
        <test>
            <!-- TopHat commands:
            tophat -o tmp_dir -p 1 tophat_in1 test-data/tophat_in2.fastqsanger
            Rename the files in tmp_dir appropriately
            -->
            <param ftype="fastqsanger" name="input1" value="tophat_in2.fastqsanger"/>
            <param name="genomeSource" value="indexed"/>
            <param name="index" value="tophat_test"/>
            <param name="sPaired" value="single"/>
            <param name="sSettingsType" value="preSet"/>
            <output file="tophat_out1j.bed" name="junctions"/>
            <output compare="sim_size" file="tophat_out1h.bam" name="accepted_hits"/>
        </test>
        <!-- Test using base-space test data: paired-end reads, index from history. -->
        <test>
            <!-- TopHat commands:
            bowtie-build -f test-data/tophat_in1.fasta tophat_in1
            tophat -o tmp_dir -p 1 -r 20 tophat_in1 test-data/tophat_in2.fastqsanger test-data/tophat_in3.fastqsanger
            Rename the files in tmp_dir appropriately
            -->
            <param ftype="fastqsanger" name="input1" value="tophat_in2.fastqsanger"/>
            <param name="genomeSource" value="history"/>
            <param ftype="fasta" name="ownFile" value="tophat_in1.fasta"/>
            <param name="sPaired" value="paired"/>
            <param ftype="fastqsanger" name="input2" value="tophat_in3.fastqsanger"/>
            <param name="mate_inner_distance" value="20"/>
            <param name="pSettingsType" value="preSet"/>
            <output file="tophat_out2j.bed" name="junctions"/>
            <output compare="sim_size" file="tophat_out2h.bam" name="accepted_hits"/>
        </test>
        <!-- Test base-space single-end reads with user-supplied reference fasta and full parameters -->
        <test>
            <!-- Tophat commands:
            bowtie-build -f test-data/tophat_in1.fasta tophat_in1
            tophat -o tmp_dir -p 1 -a 8 -m 0 -i 70 -I 500000 -F 0.15 -g 40 +coverage-search +min-coverage-intron 50 +max-coverage-intro 20000 +segment-mismatches 2 +segment-length 25 +closure-search +min-closure-exon 50 +min-closure-intron 50 +max-closure-intro 5000 +microexon-search tophat_in1 test-data/tophat_in2.fastqsanger
            Replace the + with double-dash
            Rename the files in tmp_dir appropriately
            -->
            <param ftype="fastqsanger" name="input1" value="tophat_in2.fastqsanger"/>
            <param name="genomeSource" value="history"/>
            <param name="ownFile" value="tophat_in1.fasta"/>
            <param name="sPaired" value="single"/>
            <param name="sSettingsType" value="full"/>
            <param name="library_type" value="FR Unstranded"/>
            <param name="anchor_length" value="8"/>
            <param name="splice_mismatches" value="0"/>
            <param name="min_intron_length" value="70"/>
            <param name="max_intron_length" value="500000"/>
            <param name="max_multihits" value="40"/>
            <param name="min_segment_intron" value="50"/>
            <param name="max_segment_intron" value="500000"/>
            <param name="seg_mismatches" value="2"/>
            <param name="seg_length" value="25"/>
            <param name="allow_indel_search" value="Yes"/>
            <param name="max_insertion_length" value="3"/>
            <param name="max_deletion_length" value="3"/>
            <param name="use_junctions" value="Yes"/>
            <param name="use_annotations" value="No"/>
            <param name="use_juncs" value="No"/>
            <param name="no_novel_juncs" value="No"/>
            <param name="use_search" value="Yes"/>
            <param name="min_closure_exon" value="50"/>
            <param name="min_closure_intron" value="50"/>
            <param name="max_closure_intron" value="5000"/>
            <param name="use_search" value="Yes"/>
            <param name="min_coverage_intron" value="50"/>
            <param name="max_coverage_intron" value="20000"/>
            <param name="microexon_search" value="Yes"/>
            <output file="tophat_out3i.bed" name="insertions"/>
            <output file="tophat_out3d.bed" name="deletions"/>
            <output file="tophat_out3j.bed" name="junctions"/>
            <output compare="sim_size" file="tophat_out3h.bam" name="accepted_hits"/>
        </test>
        <!-- Test base-space paired-end reads with user-supplied reference fasta and full parameters -->
        <test>
            <!-- TopHat commands:
            tophat -o tmp_dir -r 20 -p 1 -a 8 -m 0 -i 70 -I 500000 -F 0.15 -g 40 +coverage-search +min-coverage-intron 50 +max-coverage-intro 20000 +segment-mismatches 2 +segment-length 25 +microexon-search tophat_in1 test-data/tophat_in2.fastqsanger test-data/tophat_in3.fastqsanger
            Replace the + with double-dash
            Rename the files in tmp_dir appropriately
            -->
            <param ftype="fastqsanger" name="input1" value="tophat_in2.fastqsanger"/>
            <param name="genomeSource" value="indexed"/>
            <param name="index" value="tophat_test"/>
            <param name="sPaired" value="paired"/>
            <param ftype="fastqsanger" name="input2" value="tophat_in3.fastqsanger"/>
            <param name="mate_inner_distance" value="20"/>
            <param name="pSettingsType" value="full"/>
            <param name="library_type" value="FR Unstranded"/>
            <param name="mate_std_dev" value="20"/>
            <param name="anchor_length" value="8"/>
            <param name="splice_mismatches" value="0"/>
            <param name="min_intron_length" value="70"/>
            <param name="max_intron_length" value="500000"/>
            <param name="max_multihits" value="40"/>
            <param name="min_segment_intron" value="50"/>
            <param name="max_segment_intron" value="500000"/>
            <param name="seg_mismatches" value="2"/>
            <param name="seg_length" value="25"/>
            <param name="allow_indel_search" value="No"/>
            <param name="use_junctions" value="Yes"/>
            <param name="use_annotations" value="No"/>
            <param name="use_juncs" value="No"/>
            <param name="no_novel_juncs" value="No"/>
            <param name="use_search" value="No"/>
            <param name="microexon_search" value="Yes"/>
            <output file="tophat_out4j.bed" name="junctions"/>
            <output compare="sim_size" file="tophat_out4h.bam" name="accepted_hits"/>
        </test>
    </tests>

    <help>
**Tophat Overview**

TopHat_ is a fast splice junction mapper for RNA-Seq reads. It aligns RNA-Seq reads to mammalian-sized genomes using the ultra high-throughput short read aligner Bowtie, and then analyzes the mapping results to identify splice junctions between exons. Please cite: Trapnell, C., Pachter, L. and Salzberg, S.L. TopHat: discovering splice junctions with RNA-Seq. Bioinformatics 25, 1105-1111 (2009).        

.. _Tophat: http://tophat.cbcb.umd.edu/
        
------

**Know what you are doing**

.. class:: warningmark

There is no such thing (yet) as an automated gearshift in splice junction identification. It is all like stick-shift driving in San Francisco. In other words, running this tool with default parameters will probably not give you meaningful results. A way to deal with this is to **understand** the parameters by carefully reading the `documentation`__ and experimenting. Fortunately, Galaxy makes experimenting easy.

.. __: http://tophat.cbcb.umd.edu/manual.html

------

**Input formats**

Tophat accepts files in Sanger FASTQ format. Use the FASTQ Groomer to prepare your files.

------

**Outputs**

Tophat produces two output files:

- junctions -- A UCSC BED_ track of junctions reported by TopHat. Each junction consists of two connected BED blocks, where each block is as long as the maximal overhang of any read spanning the junction. The score is the number of alignments spanning the junction.
- accepted_hits -- A list of read alignments in BAM_ format.

.. _BED: http://genome.ucsc.edu/FAQ/FAQformat.html#format1
.. _BAM: http://samtools.sourceforge.net/

Two other possible outputs, depending on the options you choose, are insertions and deletions, both of which are in BED format.

-------

**Tophat settings**

All of the options have a default value. You can change any of them. Some of the options in Tophat have been implemented here.

------

**Tophat parameter list**

This is a list of implemented Tophat options::

  -r                                This is the expected (mean) inner distance between mate pairs. For, example, for paired end runs with fragments 
                                    selected at 300bp, where each end is 50bp, you should set -r to be 200. There is no default, and this parameter 
                                    is required for paired end runs.
  --mate-std-dev INT                The standard deviation for the distribution on inner distances between mate pairs. The default is 20bp.
  -a/--min-anchor-length INT        The &quot;anchor length&quot;. TopHat will report junctions spanned by reads with at least this many bases on each side of the junction. Note that individual spliced     
                                    alignments may span a junction with fewer than this many bases on one side. However, every junction involved in spliced alignments is supported by at least one 
                                    read with this many bases on each side. This must be at least 3 and the default is 8.
  -m/--splice-mismatches INT        The maximum number of mismatches that may appear in the &quot;anchor&quot; region of a spliced alignment. The default is 0.
  -i/--min-intron-length INT        The minimum intron length. TopHat will ignore donor/acceptor pairs closer than this many bases apart. The default is 70.
  -I/--max-intron-length INT        The maximum intron length. When searching for junctions ab initio, TopHat will ignore donor/acceptor pairs farther than this many bases apart, except when such a pair is supported by a split segment alignment of a long read. The default is 500000.
  -F/--min-isoform-fraction 0.0-1.0 TopHat filters out junctions supported by too few alignments. Suppose a junction spanning two exons, is supported by S reads. Let the average depth of coverage of 
                                    exon A be D, and assume that it is higher than B. If S / D is less than the minimum isoform fraction, the junction is not reported. A value of zero disables the 
                                    filter. The default is 0.15.
  -g/--max-multihits INT            Instructs TopHat to allow up to this many alignments to the reference for a given read, and suppresses all alignments for reads with more than this many 
                                    alignments. The default is 40.
  -G/--GTF [GTF 2.2 file]           Supply TopHat with a list of gene model annotations. TopHat will use the exon records in this file to build a set of known splice junctions for each gene, and will attempt to align reads to these junctions even if they would not normally be covered by the initial mapping.
  -j/--raw-juncs [juncs file]       Supply TopHat with a list of raw junctions. Junctions are specified one per line, in a tab-delimited format. Records look like: [chrom] [left] [right] [+/-], left and right are zero-based coordinates, and specify the last character of the left sequenced to be spliced to the first character of the right sequence, inclusive.
  -no-novel-juncs                   Only look for junctions indicated in the supplied GFF file. (ignored without -G)
  --no-closure-search               Disables the mate pair closure-based search for junctions. Currently, has no effect - closure search is off by default.
  --closure-search                  Enables the mate pair closure-based search for junctions. Closure-based search should only be used when the expected inner distance between mates is small (about or less than 50bp)
  --no-coverage-search              Disables the coverage based search for junctions.
  --coverage-search                 Enables the coverage based search for junctions. Use when coverage search is disabled by default (such as for reads 75bp or longer), for maximum sensitivity.
  --microexon-search                With this option, the pipeline will attempt to find alignments incident to microexons. Works only for reads 50bp or longer.
  --butterfly-search                TopHat will use a slower but potentially more sensitive algorithm to find junctions in addition to its standard search. Consider using this if you expect that your experiment produced a lot of reads from pre-mRNA, that fall within the introns of your transcripts.
  --segment-mismatches              Read segments are mapped independently, allowing up to this many mismatches in each segment alignment. The default is 2.
  --segment-length                  Each read is cut up into segments, each at least this long. These segments are mapped independently. The default is 25.
  --min-closure-exon                During closure search for paired end reads, exonic hops in the potential splice graph must be at least this long. The default is 50.
  --min-closure-intron              The minimum intron length that may be found during closure search. The default is 50.
  --max-closure-intron              The maximum intron length that may be found during closure search. The default is 5000.
  --min-coverage-intron             The minimum intron length that may be found during coverage search. The default is 50.
  --max-coverage-intron             The maximum intron length that may be found during coverage search. The default is 20000.
  --min-segment-intron              The minimum intron length that may be found during split-segment search. The default is 50.
  --max-segment-intron              The maximum intron length that may be found during split-segment search. The default is 500000.
    </help>
</tool>