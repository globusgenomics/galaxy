<tool id="gsnap" name="GSNAP" version="GSNAP: 2014-08-04">
  <description>Genomic Short-read Nucleotide Alignment Program</description>
  <requirements>
      <requirement type="package">gsnap</requirement>
  </requirements>
  <version_string>gsnap --version</version_string>
  <command>
    #if $refGenomeSource.genomeSource == "gmapdb":
      mkdir build_db_dir;
      gmap_build -d custom_build_genome -D ./build_db_dir -k 15 $refGenomeSource.gmapdb >> $gsnap_stderr 2> $gsnap_stderr;
    #end if
    #import os.path, re
    gsnap
    --gunzip
    --nthreads=&quot;8&quot; --ordered
    #if $refGenomeSource.genomeSource == &quot;gmapdb&quot;:
      --dir=./build_db_dir --db=custom_build_genome
##      #set $gmapdb = $os.listdir($refGenomeSource.gmapdb.extra_files_path)[0]
##      --dir=$refGenomeSource.gmapdb.extra_files_path --db=$refGenomeSource.gmapdb.metadata.db_name
    #else:
      --dir=$os.path.dirname($refGenomeSource.gmapindex.fields.path) --db=$os.path.basename($refGenomeSource.gmapindex.fields.path)
    #end if
##    #if $refGenomeSource.kmer != None and len($refGenomeSource.kmer.__str__) == 2:
##      --kmer=$refGenomeSource.kmer
##    #end if
##    #if $refGenomeSource.use_splicing.src == 'gmapdb':
##      #if $refGenomeSource.use_splicing.splicemap != None and len($refGenomeSource.use_splicing.splicemap.__str__) &gt; 0:
##       -s $refGenomeSource.use_splicing.splicemap.value
##        #if $computation.options == 'default':
##          #if $computation.trim_mismatch_score.__str__ == '0':
##            $ambig_splice_noclip
##          #end if
##        #end if
##      #end if
##    #elif $refGenomeSource.use_splicing.src == 'history':
##      #if $refGenomeSource.use_splicing.splicemap != None and len($refGenomeSource.use_splicing.splicemap.__str__) &gt; 0:
##        -S $os.path.dirname($refGenomeSource.use_splicing.splicemap) -s $os.path.basename($refGenomeSource.use_splicing.splicemap)
##        #if $computation.options == 'default':
##          #if $computation.trim_mismatch_score.__str__ == '0':
##            $ambig_splice_noclip
##          #end if
##        #end if
##      #end if
##    #end if
##    #if $refGenomeSource.use_snps.src == 'gmapdb':
##       #if $refGenomeSource.use_snps.snpindex != None and len($refGenomeSource.use_snps.snpindex.__str__) &gt; 0:
##        -v $refGenomeSource.use_snps.snpindex.value
##       #end if
##    #elif $refGenomeSource.use_snps.src == 'history':
##       #if $refGenomeSource.use_snps.snpindex != None and len($refGenomeSource.use_snps.snpindex.__str__) &gt; 0:
##         -V $refGenomeSource.use_snps.snpindex.extra_files_path -v $refGenomeSource.use_snps.snpindex.metadata.snps_name
##       #end if
##    #end if
##    #if $refGenomeSource.mode.__str__ != '':
##      --mode=$refGenomeSource.mode
##    #end if


##    --dir=$os.path.dirname($refGenomeSource.gmapindex.fields.path) --db=$os.path.basename($refGenomeSource.gmapindex.fields.path)


    #* ## No longer in options as of version 2011-11-30
    #if $mapq_unique_score.__str__ != '':
      --mapq-unique-score=$mapq_unique_score
    #end if
    *#
    #if $computation.options == &quot;advanced&quot;:
      #if $computation.max_mismatches.__str__ != '':
        --max-mismatches=$computation.max_mismatches
      #end if
      $computation.query_unk_mismatch
      $computation.genome_unk_mismatch
      #if $computation.terminal_threshold.__str__ != '':
        --terminal-threshold=$computation.terminal_threshold
      #end if
      #if $computation.indel_penalty.__str__ != '':
        --indel-penalty=$computation.indel_penalty
      #end if
      #if $computation.indel_endlength.__str__ != '':
        --indel-endlength=$computation.indel_endlength
      #end if
      #if $computation.max_middle_insertions.__str__ != '':
        --max-middle-insertions=$computation.max_middle_insertions
      #end if
      #if $computation.max_middle_deletions.__str__ != '':
        --max-middle-deletions=$computation.max_middle_deletions
      #end if
      #if $computation.max_end_insertions.__str__ != '':
        --max-end-insertions=$computation.max_end_insertions
      #end if
      #if $computation.max_end_deletions.__str__ != '':
        --max-end-deletions=$computation.max_end_deletions
      #end if
      #if $computation.suboptimal_levels.__str__ != '':
        --suboptimal-levels=$computation.suboptimal_levels
      #end if
      #if $computation.adapter_strip.__str__ != '':
        --adapter-strip=$computation.adapter_strip
      #end if
      #if $computation.trim_mismatch_score.__str__ != '':
        --trim-mismatch-score=$computation.trim_mismatch_score
      #end if
      #if $computation.trim_indel_score.__str__ != '':
        --trim-indel-score=$computation.trim_indel_score
      #end if
      ## TODO - do we need these options (Is it tally XOR runlength?):
      ## --tallydir=  --use-tally=tally
      ## --runlengthdir  --use-runlength=runlength
      #if $computation.use_tally and len($computation.use_tally.__str__) &gt; 0:
        ##--tallydir $os.path.dirname($computation.use_tally) --use-tally $os.path.basename($computation.use_tally)
        --use-tally=$computation.use_tally
      #end if
      ## gmap options
      #if $computation.gmap_mode.__str__ != '' and  $computation.gmap_mode.__str__ != 'None':
        --gmap-mode='$computation.gmap_mode'
      #end if
      #if $computation.trigger_score_for_gmap.__str__ != '':
        --trigger-score-for-gmap=$computation.trigger_score_for_gmap
      #end if
      #if $computation.max_gmap_pairsearch.__str__ != '' and $re.search(&quot;pairsearch&quot;,$computation.gmap_mode):
        --max-gmap-pairsearch=$computation.max_gmap_pairsearch
      #end if
      #if $computation.max_gmap_terminal.__str__ != '' and $re.search(&quot;terminal&quot;,$computation.gmap_mode):
        --max-gmap-terminal=$computation.max_gmap_terminal
      #end if
      #if $computation.max_gmap_improvement.__str__ != '' and $re.search(&quot;improv&quot;,$computation.gmap_mode):
        --max-gmap-improvement=$computation.max_gmap_improvement
      #end if
      #if $computation.microexon_spliceprob.__str__ != '':
        --microexon-spliceprob=$computation.microexon_spliceprob
      #end if
    #end if
    #if $splicing.options == &quot;advanced&quot;:
      $splicing.novelsplicing
      #if $splicing.localsplicedist.__str__ != '':
        --localsplicedist=$splicing.localsplicedist
      #end if
      #if $splicing.local_splice_penalty.__str__ != '':
        --local-splice-penalty=$splicing.local_splice_penalty
      #end if
      #if $splicing.distant_splice_penalty.__str__ != '':
        --distant-splice-penalty=$splicing.distant_splice_penalty
      #end if
      #if $splicing.local_splice_endlength.__str__ != '':
        --local-splice-endlength=$splicing.local_splice_endlength
      #end if
      #if $splicing.distant_splice_endlength.__str__ != '':
        --distant-splice-endlength=$splicing.distant_splice_endlength
      #end if
      #if $splicing.distant_splice_identity.__str__ != '':
        --distant-splice-identity=$splicing.distant_splice_identity
      #end if
    #end if
    #if $output.options == &quot;advanced&quot;:
      #if $output.npath.__str__ != '':
        --npath=$output.npath
      #end if
      $output.quiet_if_excessive
      $output.show_refdiff
      $output.clip_overlap
    #end if
    #if $result.format == &quot;sam&quot;:
      --format=sam
      $result.no_sam_headers
      #if $result.read_group_id.__str__.strip != '':
         --read-group-id='$result.read_group_id'
      #end if
      #if $result.read_group_name.__str__ != '':
         --read-group-name='$result.read_group_name'
      #end if
      #if $result.read_group_library.__str__ != '':
         --read-group-library='$result.read_group_library'
      #end if
      #if $result.read_group_platform.__str__ != '':
         --read-group-platform='$result.read_group_platform'
      #end if
      #if $result.quality_shift.__str__ != '':
        --quality-shift=$result.quality_shift
      #end if
    #elif $result.format == &quot;goby&quot;:
      #if $result.goby_output.__str__ != '':
        --goby-output='$result.goby_output'
      #end if
      #if $result.creads_window_start.__str__ != '':
        --creads-window-start=$result.creads_window_start
      #end if
      #if $result.creads_window_end.__str__ != '':
        --creads-window-end=$result.creads_window_end
      #end if
      $result.creads_complement
    #end if
    #if $results.split_output == 'yes':
      --split-output=gsnap_out
      #if $results.fails.choice == 'nofails':
        --nofails
      #elif $results.fails.choice == 'failsonly':
        --failsonly
      #end if
      $results.fails_as_input
    #else
      #if $results.fails.choice == 'nofails':
        --nofails
      #elif $results.fails.choice == 'failsonly':
        --failsonly
        $results.fails.fails_as_input
      #end if
    #end if
    #if $seq.format == &quot;gsnap_fasta&quot;:
      $seq.circularinput $seq.gsnap
    #else if $seq.format == &quot;fastq&quot;:
      #if $seq.barcode_length.__str__ != '':
        --barcode-length=$seq.barcode_length
      #end if
      #if $seq.fastq_id_start.__str__ != '':
        --fastq-id-start=$seq.fastq_id_start
      #end if
      #if $seq.fastq_id_end.__str__ != '':
        --fastq-id-end=$seq.fastq_id_end
      #end if
      #if $seq.filter_chastity.__str__ != 'off':
        --filter-chastity=$seq.filter_chastity
      #end if
      #if $seq.paired.ispaired.__str__ == 'yes':
        #if $seq.paired.pairmax_dna.__str__ != '':
          --pairmax-dna=$seq.paired.pairmax_dna
        #end if
        #if $seq.paired.pairmax_rna.__str__ != '':
          --pairmax-rna=$seq.paired.pairmax_rna
        #end if
        #if $seq.paired.pairexpect.__str__ != '':
          --pairexpect=$seq.paired.pairexpect
        #end if
        #if $seq.paired.pairdev.__str__ != '':
          --pairdev=$seq.paired.pairdev
        #end if
        $seq.fastq $seq.paired.fastq
      #else
        $seq.fastq
      #end if
    #end if
    #if $results.split_output == 'yes':
      2&gt; $gsnap_stderr
    #else:
      #if $results.fails.choice.__str__ == 'failsonly' and $results.fails.fails_as_input.__str__ != '':
        2&gt;&gt; $gsnap_stderr &gt; $gsnap_fq
      #else
        2&gt;&gt; $gsnap_stderr &gt; $gsnap_out
      #end if
    #end if

  </command>
  <inputs>
    <!-- Input data -->
    <conditional name="seq">
      <param help="" label="&lt;H2&gt;Input Sequences&lt;/H2&gt;Select the input format" name="format" type="select">
        <option value="fastq">Fastq</option>
        <!--
        <option value="goby">Goby compact-reads</option>
        -->
        <option value="gsnap_fasta">GNSAP fasta</option>
      </param>
      <when value="fastq">
        <param format="fastq" label="Select a fastq dataset" name="fastq" type="data"/>
        <conditional name="paired">
          <param checked="false" falsevalue="no" label="Use Paired Reads?" name="ispaired" truevalue="yes" type="boolean"/>
          <when value="no"/>
          <when value="yes">
            <param format="fastq" label="Select the paired reads reverse dataset" name="fastq" type="data"/>
            <param help="" label="Orientation of paired-end reads" name="orientation" type="select">
              <option value="FR">fwd-rev, typical Illumina default</option>
              <option value="RF">rev-fwd, for circularized inserts</option>
              <option value="FF">fwd-fwd, same strand</option>
            </param>
            <param help="Used if no splice file is provided and novelsplicing is off." label="Max total genomic length for DNA-Seq paired reads, or other reads without splicing (default 1000)." name="pairmax_dna" optional="true" type="integer" value=""/>
            <param help="Used when novel splicing is specified or a splice file is provided.  Should probably match the value for localsplicedist." label="Max total genomic length for RNA-Seq paired reads, or other reads that could have a splice (default 200000)." name="pairmax_rna" optional="true" type="integer" value=""/>
            <param help="Used for calling splices in medial part of paired-end reads (default 200)" label="Expected paired-end length" name="pairexpect" optional="true" type="integer" value=""/>
            <param help="Used for calling splices in medial part of paired-end reads (default 25)" label="Allowable deviation from expected paired-end length" name="pairdev" optional="true" type="integer" value=""/>
          </when>
        </conditional>
        <param label="Amount of barcode to remove from start of read (default 0)" name="barcode_length" optional="true" type="integer" value=""/>
        <param label="Starting field  of identifier in FASTQ header, whitespace-delimited, starting from 1" name="fastq_id_start" optional="true" type="integer" value=""/>
        <param help="Examples: &lt;br&gt;@HWUSI-EAS100R:6:73:941:1973#0/1&lt;br&gt; . start=1, end=1 (default)  =&gt; identifier is HWUSI-EAS100R:6:73:941:1973#0/1 &lt;br&gt;@SRR001666.1 071112_SLXA-EAS1_s_7:5:1:817:345 length=36 &lt;br&gt; . start=1, end=1  =&gt; identifier is SRR001666.1 &lt;br&gt; . start=2, end=2  =&gt; identifier is 071112_SLXA-EAS1_s_7:5:1:817:345 &lt;br&gt; . start=1, end=2  =&gt; identifier is SRR001666.1 071112_SLXA-EAS1_s_7:5:1:817:345" label="Ending field  of identifier in FASTQ header, whitespace-delimited, starting from 1" name="fastq_id_end" optional="true" type="integer" value=""/>
        <param help="String after the accession having a  'Y'  after the first colon, like this: &lt;br&gt;@accession 1:Y:0:CTTGTA &lt;br&gt;where the  'Y'  signifies filtering by chastity. &lt;br&gt; For 'either', a  'Y'  on either end of a paired-end read will be filtered. &lt;br&gt;  For 'both', a  'Y'  is required on both ends of a paired-end read (or on the only end of a single-end read)" label="Skip reads marked by the Illumina chastity program" name="filter_chastity" type="select">
          <option value="off">off - no filtering</option>
          <option value="either">either - a 'Y' on either end of a paired-end read</option>
          <option value="both">both - a 'Y' is required on both ends of a paired-end read or the only end of a single-end read</option>
        </param>
      </when>
      <!--
      <when value="goby">
      </when>
      -->
      <when value="gsnap_fasta">
        <param format="fasta" help="GSNAP fasta must have the sequence entirely on one line, a second line is interpreted as the paired-end sequence" label="Select a single-end dataset" name="gsnap" type="data"/>
        <param checked="false" falsevalue="" label="Circular-end data (paired reads are on same strand)" name="circularinput" truevalue="--circular-input=true" type="boolean"/>
      </when>
      
    </conditional>
    <!-- No longer in options as of version 2011-11-30
    <param name="mapq_unique_score"  type="integer" value="" optional="true" label="MAPQ score threshold" 
                help="For multiple results, consider as a unique result if only one of the results has a MAPQ score equal or greater than this
                      (if not selected, then reports all multiple results, up to npaths)" />
    -->

    <!-- GMAPDB for alignment -->
    <conditional name="refGenomeSource">
     <param help="Built-ins were indexed using default options" label="&lt;HR&gt;&lt;H2&gt;Align To&lt;/H2&gt;Will you select a reference genome from your history or use a built-in index?" name="genomeSource" type="select">
        <option value="indexed">Use a built-in index</option>
        <option value="gmapdb">Use a FASTA file from your history</option>
      </param>
      <when value="indexed">
        <param help="if your genome of interest is not listed - contact Galaxy team" label="Select a reference genome" name="gmapindex" type="select">
          <options from_data_table="gmap_indexes">
            <!--<column index="0" name="uid"/>
            <column index="1" name="dbkey"/>
            <column index="2" name="name"/>
            <column index="3" name="kmers"/>
            <column index="4" name="maps"/>
            <column index="5" name="snps"/>
            <column index="6" name="value"/>-->
          </options>
        </param>

<!--        <param data_ref="gmapindex" help="Defaults to highest available kmer size" label="kmer size" name="kmer" type="select">
          <options from_file="gmap_indices.loc">
            <column index="3" name="name"/>
            <column index="3" name="value"/>
            <filter column="6" ref="gmapindex" type="param_value"/>
            <filter column="3" separator="," type="multiple_splitter"/>
            <filter name="" type="add_value" value=""/>
            <filter column="3" type="sort_by"/>
          </options>
        </param>

        <param help="Assumes cmetindex and atoiindex were run on the gmap datatbase." label="Alignment mode" name="mode" type="select">
            <option value="">standard</option>
            <option value="cmet-stranded">cmet-stranded   for bisulfite-treated DNA reads (tolerance to C-to-T changes)</option>
            <option value="cmet-nonstranded">cmet-nonstranded   for bisulfite-treated DNA reads (tolerance to C-to-T changes)</option>
            <option value="atoi-stranded">atoi-stranded   for RNA-editing tolerance (A-to-G changes)</option>
            <option value="atoi-nonstranded">atoi-nonstranded   for RNA-editing tolerance (A-to-G changes)</option>
        </param>

        <conditional name="use_splicing">
          <param help="Look for splicing involving known sites or known introns at short or long distances                    See README instructions for the distinction between known sites and known introns" label="&lt;HR&gt;Known Splicesite and Introns" name="src" type="select">
            <option selected="true" value="none">None</option>
            <option value="gmapdb">From the GMAP Database</option>
            <option value="history">A Map in your history</option>
          </param>
          <when value="none"/>
          <when value="history">
            <param format="splicesites.iit,introns.iit" help="built with GMAP IIT" label="Select a splicesite map" metadata_name="dbkey" name="splicemap" type="data"/>
          </when>
          <when value="gmapdb">
            <param data_ref="gmapindex" help="" label="Use map for splicing involving known sites or known introns" name="splicemap" type="select">
              <options from_file="gmap_indices.loc">
                <column index="4" name="name"/>
                <column index="4" name="value"/>
                <filter column="6" ref="gmapindex" type="param_value"/>
                <filter column="4" separator="," type="multiple_splitter"/>
                <filter name="" type="add_value" value=""/>
                <filter column="4" type="sort_by"/>
              </options>
            </param>
          </when>
        </conditional>

        <conditional name="use_snps">
          <param help="for SNP tolerant alignments" label="&lt;HR&gt;Known SNPs" name="src" type="select">
            <option selected="true" value="none">None</option>
            <option value="gmapdb">From the GMAP Database</option>
            <option value="history">A SNP Index in your history</option>
          </param>
          <when value="none"/>
          <when value="history">
            <param format="gmapsnpindex" help="built with GMAP SNP Index" label="Select a snpindex" metadata_name="dbkey" name="snpindex" type="data"/>
          </when>
          <when value="gmapdb">
            <param data_ref="gmapindex" help="" label="Use database containing known SNPs" name="snpindex" type="select">
              <options from_file="gmap_indices.loc">
                <column index="5" name="name"/>
                <column index="5" name="value"/>
                <filter column="6" ref="gmapindex" type="param_value"/>
                <filter column="5" separator="," type="multiple_splitter"/>
                <filter name="" type="add_value" value=""/>
                <filter column="5" type="sort_by"/>
              </options>
            </param>
          </when>
        </conditional>
-->
      </when>
      <when value="gmapdb">
        <param format="fasta" help="A fasta file to create the GMAPDB" label="Select a FASTA file" name="gmapdb" type="data"/>
<!--
        <param data_ref="gmapdb" help="Defaults to highest available kmer size" label="kmer size" name="kmer" type="select">
          <options>
            <filter key="kmers" multiple="True" ref="gmapdb" separator="," type="data_meta"/>
          </options>
        </param>

        <param help="Assumes cmetindex and atoiindex were run on the gmap datatbase." label="Alignment mode" name="mode" type="select">
            <option value="">standard</option>
            <option value="cmet-stranded">cmet-stranded   for bisulfite-treated DNA reads (tolerance to C-to-T changes)</option>
            <option value="cmet-nonstranded">cmet-nonstranded   for bisulfite-treated DNA reads (tolerance to C-to-T changes)</option>
            <option value="atoi-stranded">atoi-stranded   for RNA-editing tolerance (A-to-G changes)</option>
            <option value="atoi-nonstranded">atoi-nonstranded   for RNA-editing tolerance (A-to-G changes)</option>
        </param>

        <conditional name="use_splicing">
          <param help="Look for splicing involving known sites or known introns at short or long distances. See README instructions for the distinction between known sites and known introns" label="&lt;HR&gt;Known Splicesite and Introns" name="src" type="select">
            <option selected="true" value="none">None</option>
            <option value="gmapdb">From the GMAP Database</option>
            <option value="history">A Map in your history</option>
          </param>
          <when value="none"/>
          <when value="history">
            <param format="splicesites.iit,introns.iit" help="built with GMAP IIT" label="Select a splicesite map" metadata_name="dbkey" name="splicemap" type="data"/>
            <param checked="false" falsevalue="" help="For ambiguous known splicing at ends of the read, do not clip at the splice site, but extend instead into the intron.  This flag makes sense only if you are trying to eliminate all soft clipping with - -trim-mismatch-score=0" label="Do not clip at ambiguous splice sites" name="ambig_splice_noclip" truevalue="- -ambig-splice-noclip" type="boolean"/>
          </when>
          <when value="gmapdb">
            <param data_ref="gmapdb" help="" label="Use map for splicing involving known sites or known introns" name="splicemap" type="select">
              <options>
                <filter key="maps" multiple="True" ref="gmapdb" type="data_meta"/>
              </options>
            </param>
            <param checked="false" falsevalue="" help="For ambiguous known splicing at ends of the read, do not clip at the splice site, but extend instead into the intron.  This flag makes sense only if you are trying to eliminate all soft clipping with - -trim-mismatch-score=0" label="Do not clip at ambiguous splice sites" name="ambig_splice_noclip" truevalue="- -ambig-splice-noclip" type="boolean"/>
          </when>
        </conditional>

        <conditional name="use_snps">
          <param help="for SNP tolerant alignments" label="&lt;HR&gt;Known SNPs" name="src" type="select">
            <option selected="true" value="none">None</option>
            <option value="gmapdb">From the GMAP Database</option>
            <option value="history">A SNP Index in your history</option>
          </param>
          <when value="none"/>
          <when value="history">
            <param format="gmapsnpindex" help="built with GMAP SNP Index" label="Select a snpindex" metadata_name="dbkey" name="snpindex" type="data"/>
          </when>
          <when value="gmapdb">
            <param data_ref="gmapdb" help="" label="Use database containing known SNPs" name="snpindex" type="select">
              <options>
                <filter key="snps" multiple="True" ref="gmapdb" separator="," type="data_meta"/>
              </options>
            </param>
          </when>
        </conditional>
-->
      </when>
    </conditional>
    <!-- Computation options -->
    <conditional name="computation">
      <param help="" label="&lt;HR&gt;Computational Settings" name="options" type="select">
        <option value="default">Use default settings</option>
        <option value="advanced">Set Computation Options</option>
      </param>
      <when value="default"/>
      <when value="advanced">
         <param help="Defaults to the ultrafast level of ((readlength+2)/12 - 2)). If specified between 0.0 and 1.0, then treated as a fraction of each read length.  Otherwise, treated as an integral number of mismatches (including indel and splicing penalties). For RNA-Seq, you may need to increase this value slightly to align reads extending past the ends of an exon." label="Maximum number of mismatches allowed (uses default when negative)" name="max_mismatches" optional="true" type="float" value="">
            <validator message="The mismatches must &gt;= 0." min="0." type="in_range"/>
         </param>
         <param checked="false" falsevalue="" label="Count unknown (N) characters in the query as a mismatch" name="query_unk_mismatch" truevalue="--query-unk-mismatch=1" type="boolean"/>
         <param checked="true" falsevalue="--genome-unk-mismatch=0" label="Count unknown (N) characters in the genome as a mismatch" name="genome_unk_mismatch" truevalue="" type="boolean"/>
         <param help="(from one end of the read to the best possible position at the other end).   For example, if this value is 2, then if GSNAP finds an exact or 1-mismatch alignment, it will not try to find a terminal alignment. Note that this default value may not be low enough if you want to obtain terminal alignments for very short reads, although such reads probably don't have enough specificity for terminal alignments anyway." label="Threshold for searching for a terminal alignment (default 2)" name="terminal_threshold" optional="true" type="integer" value=""/>
         <param help="Counts against mismatches allowed.  To find indels, make indel-penalty less than or equal to max-mismatches.  A value &lt; 2 can lead to false positives at read ends" label="Penalty for an indel (default 2)" name="indel_penalty" optional="true" type="integer" value=""/>
         <param label="Minimum length at end required for indel alignments (default 4)" name="indel_endlength" optional="true" type="integer" value=""/>
         <param label="Maximum number of middle insertions allowed (default 9)" name="max_middle_insertions" optional="true" type="integer" value=""/>
         <param label="Maximum number of middle deletions allowed (default 30)" name="max_middle_deletions" optional="true" type="integer" value=""/>
         <param label="Maximum number of end insertions allowed (default 3)" name="max_end_insertions" optional="true" type="integer" value=""/>
         <param label="Maximum number of end deletions allowed (default 6)" name="max_end_deletions" optional="true" type="integer" value=""/>
         <param help="All hits with best score plus suboptimal-levels are reported" label="Report suboptimal hits beyond best hit (default 0)" name="suboptimal_levels" optional="true" type="integer" value=""/>
         <param help="paired removes adapters from paired-end reads if a concordant or paired alignment cannot be found from the original read" label="Method for removing adapters from reads" name="adapter_strip" type="select">
           <option selected="true" value="paired">paired</option>
           <option value="off">off</option>
         </param>
         <param help="to turn off trimming, specify 0 (Warning: turning trimming off will give false positive mismatches at the ends of reads)" label="Score to use for mismatches when trimming at ends (default is -3)" name="trim_mismatch_score" optional="true" type="integer" value=""/>
         <param help="to turn off trimming, specify 0 (Warning: turning trimming off will give false positive indels at the ends of reads)" label="Score to use for indels when trimming at ends (default is -4)" name="trim_indel_score" optional="true" type="integer" value=""/>
         <param format="tally.iit" help="generated by gsnap_tally and iit_store" label="Select a tally IIT file to resolve concordant multiple results" metadata_name="dbkey" name="use_tally" optional="true" type="data"/>

         <!--
           tallydir=STRING              Directory for tally IIT file to resolve concordant multiple results (default is
                                              location of genome index files specified using -D and -d).  Note: can
                                              just give full path name to use-tally instead.
           use-tally=STRING             Use this tally IIT file to resolve concordant multiple results
           runlengthdir=STRING          Directory for runlength IIT file to resolve concordant multiple results (default is
                                              location of genome index files specified using -D and -d).  Note: can
                                              just give full path name to use-runlength instead.
           use-runlength=STRING         Use this runlength IIT file to resolve concordant multiple results
         -->
         
         <!-- Options for GMAP alignment within GSNAP -->
          <param display="checkboxes" help="Default: pairsearch,terminal,improve" label="Cases to use GMAP for complex alignments containing multiple splices or indels" multiple="true" name="gmap_mode" optional="true" type="select">
            <option selected="true" value="pairsearch">pairsearch</option>
            <option selected="true" value="terminal">terminal</option>
            <option selected="true" value="improve">improve</option>
          </param>
          <param help="Try GMAP pairsearch on nearby genomic regions if best score (the total of both ends if paired-end) exceeds this value (default 5)" label="GMAP pairsearch threshold (default 5)" name="trigger_score_for_gmap" optional="true" type="integer" value=""/>
          <param help="Perform GMAP pairsearch on nearby genomic regions up to this many candidate ends (default 3)." label="GMAP pairsearch threshold (default 3)" name="max_gmap_pairsearch" optional="true" type="integer" value=""/>
          <param help="Perform GMAP terminal on nearby genomic regions up to this many candidate ends (default 3)." label="GMAP terminal threshold (default 3)" name="max_gmap_terminal" optional="true" type="integer" value=""/>
          <param help="Perform GMAP improvement on nearby genomic regions up to this many candidate ends (default 3)." label="GMAP improvement threshold (default 3)" name="max_gmap_improvement" optional="true" type="integer" value=""/>
          <param help="Allow microexons only if one of the splice site probabilities is greater than this value." label="GMAP microexons threshold (default .90)" name="microexon_spliceprob" optional="true" type="float" value="">
            <validator max="1." message="The microexons  probability must be between 0. and 1." min="0." type="in_range"/>
          </param>
      </when>
    </conditional>

    <conditional name="splicing">
      <param help="" label="&lt;HR&gt;Splicing options for RNA-Seq" name="options" type="select">
        <option value="default">Use default settings</option>
        <option value="advanced">Set Splicing Options</option>
      </param>
      <when value="default"/>
      <when value="advanced">
         <!-- Splicing options for RNA-Seq -->
         <!-- use-splicing This should be either a select list from the gmapdb maps or a data type using splicesdir and use-splicing --> 
         <!-- Neither novel splicing (-N) nor known splicing (-s) turned on => assume reads are DNA-Seq (genomic) -->
         <param checked="false" falsevalue="" label="Look for novel splicing " name="novelsplicing" truevalue="--novelsplicing=1" type="boolean"/>
         <param label="Definition of local novel splicing event (default 200000)" name="localsplicedist" optional="true" type="integer" value=""/>
         <param label="Penalty for a local splice (default 0).  Counts against mismatches allowed" name="local_splice_penalty" optional="true" type="integer" value=""/>
         <param name="local_splice_endlength" label="Minimum length at end required for local spliced alignments" help="-k, --local-splice-endlength=INT, default 15, min is 14" optional="true" value="" type="integer"/>
         <param help="A distant splice is one where the intron length exceeds the value of localsplicedist or is an inversion, scramble, or translocation between two different chromosomes. Counts against mismatches allowed" label="Penalty for a distant splice (default 3).  Counts against mismatches allowed" name="distant_splice_penalty" optional="true" type="integer" value=""/>
         <param help="(default 16, min is the kmer length)" label="Minimum length at end required for distant spliced alignments" name="distant_splice_endlength" optional="true" type="integer" value=""/>
         <param help="(default 2, but unless known splice sites are provided,  GSNAP may still need the end length to be the value of kmer size to find a given splice" label="Minimum length at end required for short-end spliced alignments" name="shortend_splice_endlength" optional="true" type="integer" value=""/>
         <param label="Minimum identity at end required for distant spliced alignments (default 0.95)" name="distant_splice_identity" optional="true" type="float" value=""/>
         <param help="A positive value, such as 1, expects antisense on the first read and sense on the second read. Default is 0, which treats sense and antisense equally well" label="Penalty for antistranded splicing when using stranded RNA-Seq protocols" name="antistranded_penalty" optional="true" type="integer" value=""/>
      </when>
    </conditional>

    <!-- Output data -->
    <conditional name="output">
      <param help="" label="&lt;HR&gt;&lt;H2&gt;Output&lt;/H2&gt;Output options for RNA-Seq" name="options" type="select">
        <option value="default">Use default settings</option>
        <option value="advanced">Set Output Options</option>
      </param>
      <when value="default"/>
      <when value="advanced">
        <param label="Maximum number of paths to print (default 100)" name="npath" optional="true" type="integer" value=""/>
        <param checked="false" falsevalue="" help="If more than maximum number of paths are found, then nothing is printed." label="Quiet if Excessive" name="quiet_if_excessive" truevalue="--quiet-if-excessive" type="boolean"/>
        <param checked="false" falsevalue="" help="For GSNAP output in SNP-tolerant alignment, shows all differences relative to the reference genome as lower case (otherwise, it shows all differences relative to both the reference and alternate genome)" label="Show SNP-tolerant alignment" name="show_refdiff" truevalue="--show-refdiff" type="boolean"/>
        <param checked="false" falsevalue="" help="For paired-end reads whose alignments overlap, clip the overlapping region." label="Clip Overlap" name="clip_overlap" truevalue="--clip-overlap" type="boolean"/>
      </when>
    </conditional>
    <conditional name="result">
      <param help="" label="Select the output format" name="format" type="select">
        <option value="sam">SAM</option>
        <!--  goby should only be an option if the input is in goby format
        <option value="goby">Goby</option>
        -->
        <option value="gsnap">GSNAP default output</option>
      </param>
      <when value="gsnap">
      </when>
      <when value="sam">
        <param checked="false" falsevalue="" label="Do not print headers beginning with '@'" name="no_sam_headers" truevalue="--no-sam-headers" type="boolean"/>
        <param label="Value to put into read-group id (RG-ID) field" name="read_group_id" optional="true" type="text" value=""/>
        <param label="Value to put into read-group name (RG-SM) field" name="read_group_name" optional="true" type="text" value=""/>
        <param label="Value to put into read-group library (RG-LB) field" name="read_group_library" optional="true" type="text" value=""/>
        <param label="Value to put into read-group library platform (RG-PL) field" name="read_group_platform" optional="true" type="text" value=""/>
        <param label="Shift FASTQ quality scores by this amount in SAM output (default -31)" name="quality_shift" optional="true" type="integer" value=""/>
      </when>
      <!--
      <when value="goby">
        <param name="goby_output" type="text" value="" label="Basename for Goby output files"/>
        <param name="creads_window_start"  type="integer" value="" optional="true" label="Compact reads window start (default: 0=start of file)"/>
        <param name="creads_window_end"  type="integer" value="" optional="true" label="Compact reads window end (default: 0=end of file)"/>
        <param name="creads_complement" type="boolean" truevalue="-\-creads-complement" falsevalue="" checked="false" label="Complement read sequences (without reversing)"/>
      </when>
      -->
    </conditional>
    <!-- TODO combine fails and split_output -->

    <conditional name="results">
      <param help="Separate outputs for: nomapping, halfmapping_uniq, halfmapping_mult, unpaired_uniq, unpaired_mult, paired_uniq, paired_mult, concordant_uniq, and concordant_mult results" label="&lt;HR&gt;Split outputs" name="split_output" type="select"> 
        <option value="no">no</option>
        <option value="yes">yes</option>
      </param>
      <when value="no">
        <conditional name="fails">
          <param help="" label="How to deal with fails" name="choice" type="select">
            <option value="default">default - include them in results</option>
            <option value="nofails">nofails - exclude fails from results</option>
            <option value="failsonly">failsonly - only output failing results</option>
          </param>
          <when value="default"/>
          <when value="nofails"/>
          <when value="failsonly">
            <param checked="false" falsevalue="" help="" label="Print completely failed alignments as input FASTA or FASTQ format" name="fails_as_input" truevalue="--fails-as-input" type="boolean"/> 
          </when>
        </conditional>
      </when>
      <when value="yes">
        <conditional name="fails">
          <param help="" label="How to deal with fails" name="choice" type="select">
            <option value="default">default - include them in results</option>
            <option value="nofails">nofails - exclude fails from results</option>
            <option value="failsonly">failsonly - only output failing results</option>
          </param>
          <when value="default"/>
          <when value="nofails"/>
          <when value="failsonly"/>
        </conditional>
        <param checked="false" falsevalue="" help="" label="Print completely failed alignments as input FASTA or FASTQ format" name="fails_as_input" truevalue="--fails-as-input" type="boolean"/> 
      </when>
    </conditional>

  </inputs>
  <outputs>
    <data format="txt" label="${tool.name} on ${on_string}: gsnap.log" name="gsnap_stderr"/>

    <data format="txt" label="${tool.name} on ${on_string} ${result.format}" name="gsnap_out">
      <filter>(results['split_output'] == 'no' and (results['fails']['choice'] != 'failsonly' or results['fails']['fails_as_input'] == False))</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>

    <data format="fastq" label="${tool.name} on ${on_string} fails.fq" name="gsnap_fq">
      <filter>(results['split_output'] == 'no' and results['fails']['choice'] == 'failsonly' and results['fails']['fails_as_input'] == True)</filter>
    </data>

    <!-- nomapping, halfmapping_uniq, halfmapping_mult, unpaired_uniq, unpaired_mult, paired_uniq, paired_mult, concordant_uniq, concordant_mult -->

    <data format="txt" from_work_dir="gsnap_out.unpaired_mult" label="${tool.name} on ${on_string} unpaired_mult.${result.format}" name="unpaired_mult">
      <filter>(results['split_output'] == 'yes')</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.unpaired_uniq" label="${tool.name} on ${on_string} unpaired_uniq.${result.format}" name="unpaired_uniq">
      <filter>(results['split_output'] == 'yes')</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.unpaired_transloc" label="${tool.name} on ${on_string} unpaired_transloc.${result.format}" name="unpaired_transloc">
      <filter>(results['split_output'] == 'yes')</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.halfmapping_mult" label="${tool.name} on ${on_string} halfmapping_mult.${result.format}" name="halfmapping_mult">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.halfmapping_uniq" label="${tool.name} on ${on_string} halfmapping_uniq.${result.format}" name="halfmapping_uniq">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.halfmapping_transloc" label="${tool.name} on ${on_string} halfmapping_transloc.${result.format}" name="halfmapping_transloc">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.paired_mult" label="${tool.name} on ${on_string} paired_mult.${result.format}" name="paired_mult">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.paired_uniq" label="${tool.name} on ${on_string} paired_uniq.${result.format}" name="paired_uniq">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.paired_transloc" label="${tool.name} on ${on_string} paired_transloc.${result.format}" name="paired_transloc">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>

    <data format="txt" from_work_dir="gsnap_out.concordant_mult" label="${tool.name} on ${on_string} concordant_mult.${result.format}" name="concordant_mult">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.concordant_uniq" label="${tool.name} on ${on_string} concordant_uniq.${result.format}" name="concordant_uniq">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>
    <data format="txt" from_work_dir="gsnap_out.concordant_transloc" label="${tool.name} on ${on_string} concordant_transloc.${result.format}" name="concordant_transloc">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>

    <data format="txt" from_work_dir="gsnap_out.nomapping" label="${tool.name} on ${on_string} nomapping.${result.format}" name="nomapping">
      <filter>(results['split_output'] == 'yes' and results['fails_as_input'] == False)</filter>
      <change_format>
        <when format="sam" input="result['format']" value="sam"/>
        <when format="gsnap" input="result['format']" value="gsnap"/>
      </change_format>
    </data>

    <data format="fastq" from_work_dir="gsnap_out.nomapping.fq" label="${tool.name} on ${on_string} nomapping.fq" name="nomapping_fq">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == False)</filter>
    </data>

    <data format="fastq" from_work_dir="gsnap_out.nomapping.1.fq" label="${tool.name} on ${on_string} nomapping.1.fq" name="nomapping_1_fq">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
    </data>

    <data format="fastq" from_work_dir="gsnap_out.nomapping.2.fq" label="${tool.name} on ${on_string} nomapping.2.fq" name="nomapping_2_fq">
      <filter>(results['split_output'] == 'yes' and seq['format'] == 'fastq' and seq['paired']['ispaired'] == True)</filter>
    </data>

    <!-- Will problay need wrapper code to generate composite datatype for goby alignment
    <data format="gobyalignment" name="goby_alignment" label="${tool.name} on ${on_string} uniq.${result.format}"  from_work_dir="gsnap_out.nomapping">
      <filter>result['format'] == 'goby'</filter>
    </data>
    -->

  </outputs>
  <tests>
  </tests> 

  <help>

**What it does**

GSNAP_ (Genomic Short-read Nucleotide Alignment Program) is a short read aligner which can align both single- and paired-end reads as short as 14nt and of arbitrarily long length. It can detect short- and long-distance splicing, including interchromosomal splicing, in individual reads, using probabilistic models or a database of known splice sites. Our program also permits SNP-tolerant alignment to a reference space of all possible combinations of major and minor alleles, and can align reads from bisulfite-treated DNA for the study of methylation state. It is developed by Thomas D. Wu of Genentech, Inc.  
Publication_ citation: Thomas D. Wu, Serban Nacu &quot;Fast and SNP-tolerant detection of complex variants and splicing in short reads. Bioinformatics. 2010 Apr 1;26(7):873-81. Epub 2010 Feb 10.

.. _GSNAP: http://research-pub.gene.com/gmap/
.. _Publication: http://bioinformatics.oupjournals.org/cgi/content/full/26/7/873

http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2844994/?tool=pubmed

------

**Know what you are doing**

.. class:: warningmark

You will want to read the README_

.. _README: http://research-pub.gene.com/gmap/src/README

------

**Input formats**

Input to GSNAP should be either in FASTQ or FASTA format.  

The FASTQ input may include quality scores, which will then be included in SAM
output, if that output format is selected. 

For FASTA format, you should include one line per read (or end of a
paired-end read).  The same FASTA file can have a mixture of
single-end and paired-end reads of varying lengths, if desired.

Single-end reads:

Each FASTA entry should contain one short read per line, like this

&gt;Header information
AAAACATTCTCCTCCGCATAAGCCTGCGTCAGATTA

Each short read can have a different length.  However, the entire read
needs to be on a single line, and may not wrap around multiple lines.
If it extends to a second line, GSNAP will think that the read is
paired-end.


Paired-end reads:

Each FASTA entry should contain two short reads, one per line, like
this

&gt;Header information
AAAACATTCTCCTCCGCATAAGCCTAGTAGATTA
GGCGTAGGTAGAAGTAGAGGTTAAGGCGCGTCAG

By default, the program assumes that the second end is in the reverse
complement direction compared with the first end.  If they are in the
same direction, you may need to use the --circular-input (or -c) flag.

( The Galaxy tool: &quot;FASTA Width formatter&quot;  can be used to reformat fasta files to have single line sequences. )

------

**Output formats in GSNAP**

SAM output format

Default GSNAP format
  See the README_




  </help>
</tool>
