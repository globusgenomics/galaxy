<tool id="gatk2_variant_recalibrator" name="Variant Recalibrator" version="GATK2: GenomeAnalysisTK-2.8-1-g932cd3a; SAMTOOLS: 1.2">
  <description/>
  <requirements>
      <requirement type="package">gatk2</requirement>
      <requirement type="package">samtools</requirement>
  </requirements>
  <command interpreter="python">gatk2_wrapper.py
   --max_jvm_heap_fraction &quot;1&quot;
   --stdout &quot;${output_log}&quot;
   #for $var_count, $variant in enumerate( $reference_source.variants ):
      -d &quot;--input:input_${var_count},%(file_type)s&quot; &quot;${variant.input_variants}&quot; &quot;${variant.input_variants.ext}&quot; &quot;input_variants_${var_count}&quot;
   #end for
   -p 'java 
    -jar &quot;\$GATK2_PATH/GenomeAnalysisTK.jar&quot;
    -T &quot;VariantRecalibrator&quot;
    \$GATK2_SITE_OPTIONS
    \$GATK2_NUM_THREADS
    --num_threads 32 ##hard coded, for now
    ##-et &quot;NO_ET&quot; -K &quot;\$GATK2_BASE/gatk2_key_file&quot;##ET no phone home
    ##-log &quot;${output_log}&quot; ##don't use this to log to file, instead directly capture stdout
    #if $reference_source.reference_source_selector != &quot;history&quot;:
        -R &quot;${reference_source.ref_file.fields.path}&quot;
    #end if
    --recal_file &quot;${output_recal}&quot;
    --tranches_file &quot;${output_tranches}&quot;
    --rscript_file &quot;${output_rscript}&quot;
   '
    
    #set $rod_binding_names = dict()
    #for $rod_binding in $rod_bind:
        #if str( $rod_binding.rod_bind_type.rod_bind_type_selector ) == 'custom':
            #set $rod_bind_name = $rod_binding.rod_bind_type.custom_rod_name
        #elif str( $rod_binding.rod_bind_type.rod_bind_type_selector ) == 'comp':
            #set $rod_bind_name = &quot;comp&quot; + $rod_binding.rod_bind_type.custom_rod_name
        #else 
            #set $rod_bind_name = $rod_binding.rod_bind_type.rod_bind_type_selector
        #end if
        #set $rod_binding_names[$rod_bind_name] = $rod_binding_names.get( $rod_bind_name, -1 ) + 1
        #if $rod_binding.rod_bind_type.rod_training_type.rod_training_type_selector == &quot;not_training_truth_known&quot;:
            -d &quot;--resource:${rod_bind_name},%(file_type)s&quot; &quot;${rod_binding.rod_bind_type.input_rod}&quot; &quot;${rod_binding.rod_bind_type.input_rod.ext}&quot; &quot;input_${rod_bind_name}_${rod_binding_names[$rod_bind_name]}&quot;
        #else:
            -d &quot;--resource:${rod_bind_name},%(file_type)s,known=${rod_binding.rod_bind_type.rod_training_type.known},training=${rod_binding.rod_bind_type.rod_training_type.training},truth=${rod_binding.rod_bind_type.rod_training_type.truth},bad=${rod_binding.rod_bind_type.rod_training_type.bad},prior=${rod_binding.rod_bind_type.rod_training_type.prior}&quot; &quot;${rod_binding.rod_bind_type.input_rod}&quot; &quot;${rod_binding.rod_bind_type.input_rod.ext}&quot; &quot;input_${rod_bind_name}_${rod_binding_names[$rod_bind_name]}&quot;
        #end if
    #end for
    
    ##start standard gatk options
    #if $gatk_param_type.gatk_param_type_selector == &quot;advanced&quot;:
        #for $pedigree in $gatk_param_type.pedigree:
            -p '--pedigree &quot;${pedigree.pedigree_file}&quot;'
        #end for
        #for $pedigree_string in $gatk_param_type.pedigree_string_repeat:
            -p '--pedigreeString &quot;${pedigree_string.pedigree_string}&quot;'
        #end for
        -p '--pedigreeValidationType &quot;${gatk_param_type.pedigree_validation_type}&quot;'
        #set default_read_filters = ['DuplicateRead','FailsVendorQualityCheck','NotPrimaryAlignment','MalformedRead','UnmappedRead']
        #for $read_filter in $gatk_param_type.read_filter:
            -p '
            #if $read_filter.read_filter_type.read_filter_type_selector not in $default_read_filters:
                --read_filter &quot;${read_filter.read_filter_type.read_filter_type_selector}&quot;
            #end if
            #for $name, $param in $read_filter.read_filter_type.iteritems():
                #if $name not in [ &quot;__current_case__&quot;, &quot;read_filter_type_selector&quot; ]:
                    #if hasattr( $param.input, 'truevalue' ):
                        ${param}
                    #else:
                        --${name} &quot;${param}&quot;
                    #end if
                #end if
            #end for
            '
        #end for
        #for $interval_count, $input_intervals in enumerate( $gatk_param_type.input_interval_repeat ):
            -d &quot;--intervals&quot; &quot;${input_intervals.input_intervals}&quot; &quot;${input_intervals.input_intervals.ext}&quot; &quot;input_intervals_${interval_count}&quot;
        #end for
        
        #for $interval_count, $input_intervals in enumerate( $gatk_param_type.input_exclude_interval_repeat ):
            -d &quot;--excludeIntervals&quot; &quot;${input_intervals.input_exclude_intervals}&quot; &quot;${input_intervals.input_exclude_intervals.ext}&quot; &quot;input_exlude_intervals_${interval_count}&quot;
        #end for

        -p '--interval_set_rule &quot;${gatk_param_type.interval_set_rule}&quot;'
        
        -p '--downsampling_type &quot;${gatk_param_type.downsampling_type.downsampling_type_selector}&quot;'
        #if str( $gatk_param_type.downsampling_type.downsampling_type_selector ) != &quot;NONE&quot;:
            -p '--${gatk_param_type.downsampling_type.downsample_to_type.downsample_to_type_selector} &quot;${gatk_param_type.downsampling_type.downsample_to_type.downsample_to_value}&quot;'
        #end if
        -p '
        --baq &quot;${gatk_param_type.baq}&quot;
        --baqGapOpenPenalty &quot;${gatk_param_type.baq_gap_open_penalty}&quot;
        ${gatk_param_type.use_original_qualities}
        --defaultBaseQualities &quot;${gatk_param_type.default_base_qualities}&quot;
        --validation_strictness &quot;${gatk_param_type.validation_strictness}&quot;
        --interval_merging &quot;${gatk_param_type.interval_merging}&quot;
        ${gatk_param_type.disable_experimental_low_memory_sharding}
        ${gatk_param_type.fix_misencoded_quality_scores}
        ${gatk_param_type.non_deterministic_random_seed}
        '
        #for $rg_black_list_count, $rg_black_list in enumerate( $gatk_param_type.read_group_black_list_repeat ):
            #if $rg_black_list.read_group_black_list_type.read_group_black_list_type_selector == &quot;file&quot;:
                -d &quot;--read_group_black_list&quot; &quot;${rg_black_list.read_group_black_list_type.read_group_black_list}&quot; &quot;txt&quot; &quot;input_read_group_black_list_${rg_black_list_count}&quot;
            #else
                -p '--read_group_black_list &quot;${rg_black_list.read_group_black_list_type.read_group_black_list}&quot;'
            #end if
        #end for
    #end if
    
    #if str( $reference_source.reference_source_selector ) == &quot;history&quot;:
        -d &quot;-R&quot; &quot;${reference_source.ref_file}&quot; &quot;${reference_source.ref_file.ext}&quot; &quot;gatk_input_reference_fasta&quot;
        --picard_jar &quot;${GALAXY_DATA_INDEX_DIR}/shared/jars/picard/CreateSequenceDictionary.jar&quot;
    #end if
    ##end standard gatk options
    
    ##start analysis specific options
    -p '
    #if str( $annotations ) != &quot;None&quot;:
        #for $annotation in str( $annotations.fields.gatk_value ).split( ',' ):
            --use_annotation &quot;${annotation}&quot;
        #end for
    #end if
    #for $additional_annotation in $additional_annotations:
        --use_annotation &quot;${additional_annotation.additional_annotation_name}&quot;
    #end for
    --mode &quot;${mode}&quot;
    '
    
    #if $analysis_param_type.analysis_param_type_selector == &quot;advanced&quot;:
        -p '
        --maxGaussians &quot;${analysis_param_type.max_gaussians}&quot;
        --maxIterations &quot;${analysis_param_type.max_iterations}&quot;
        --numKMeans &quot;${analysis_param_type.num_k_means}&quot;
        --stdThreshold &quot;${analysis_param_type.std_threshold}&quot;
        --qualThreshold &quot;${analysis_param_type.qual_threshold}&quot;
        --shrinkage &quot;${analysis_param_type.shrinkage}&quot;
        --dirichlet &quot;${analysis_param_type.dirichlet}&quot;
        --priorCounts &quot;${analysis_param_type.prior_counts}&quot;
        #if str( $analysis_param_type.bad_variant_selector.bad_variant_selector_type ) == 'percent':
            --percentBadVariants &quot;${analysis_param_type.bad_variant_selector.percent_bad_variants}&quot;
        #else:
            --minNumBadVariants &quot;${analysis_param_type.bad_variant_selector.min_num_bad_variants}&quot;
        #end if
        --target_titv &quot;${analysis_param_type.target_titv}&quot;
        #for $tranche in [ $tranche.strip() for $tranche in str( $analysis_param_type.ts_tranche ).split( ',' ) if $tranche.strip() ]
            --TStranche &quot;${tranche}&quot;
        #end for
        #for $ignore_filter in $analysis_param_type.ignore_filters:
            #set $ignore_filter_name = str( $ignore_filter.ignore_filter_type.ignore_filter_type_selector )
            #if $ignore_filter_name == &quot;custom&quot;:
              #set $ignore_filter_name = str( $ignore_filter.ignore_filter_type.filter_name )
            #end if
            --ignore_filter &quot;${ignore_filter_name}&quot;
        #end for
        --ts_filter_level &quot;${analysis_param_type.ts_filter_level}&quot;
        '
    #end if
    
    
    &amp;&amp;
    mv &quot;${output_rscript}.pdf&quot; &quot;${output_tranches_pdf}&quot;
    
  </command>
  <inputs>
    <conditional name="reference_source">
      <param label="Choose the source for the reference list" name="reference_source_selector" type="select">
        <option value="cached">Locally cached</option>
        <option value="history">History</option>
      </param>
      <when value="cached">
        <repeat help="-input,--input &amp;lt;input&amp;gt;" min="1" name="variants" title="Variant">
          <param format="vcf" label="Variant file to recalibrate" name="input_variants" type="data"/>
        </repeat>
        <param help="-R,--reference_sequence &amp;lt;reference_sequence&amp;gt;" label="Using reference genome" name="ref_file" type="select">
          <options from_data_table="gatk_picard_indexes">
          <!--  <filter type="data_meta" key="dbkey" ref="variants[0].input_variants" column="dbkey"/> -->
          </options>
          <validator message="A built-in reference genome is not available for the build associated with the selected input file" type="no_options"/>
        </param>
      </when>
      <when value="history"> <!-- FIX ME!!!! -->
        <repeat help="-input,--input &amp;lt;input&amp;gt;" min="1" name="variants" title="Variant">
          <param format="vcf" label="Variant file to recalibrate" name="input_variants" type="data"/>
        </repeat>
        <param format="fasta" help="-R,--reference_sequence &amp;lt;reference_sequence&amp;gt;" label="Using reference file" name="ref_file" type="data"/>
      </when>
    </conditional>
    
    <repeat help="-resource,--resource &amp;lt;resource&amp;gt;" name="rod_bind" title="Binding for reference-ordered data">
        <conditional name="rod_bind_type">
          <param label="Binding Type" name="rod_bind_type_selector" type="select">
            <option selected="True" value="dbsnp">dbSNP</option>
            <option value="variant">Variants</option>
            <option value="snps">SNPs</option>
            <option value="indels">INDELs</option>
            <option value="hapmap">HapMap</option>
            <option value="omni">OMNI</option>
            <option value="mask">Mask</option>
            <option value="custom">Custom</option>
            <option value="comp">Comp</option>
          </param>
          <when value="variant">
              <param format="vcf" label="Variant ROD file" name="input_rod" type="data"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>
          <when value="comp">
              <param format="vcf" label="ROD file" name="input_rod" type="data"/>
              <param label="ROD Name" name="custom_rod_name" type="text" value="Unnamed"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>
          <when value="mask">
              <param format="vcf" label="ROD file" name="input_rod" type="data"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>          
          <when value="dbsnp">
              <param format="vcf" label="ROD file" name="input_rod" type="data"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>
          <when value="snps">
              <param format="vcf" label="ROD file" name="input_rod" type="data"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>
          <when value="hapmap">
              <param format="vcf" label="ROD file" name="input_rod" type="data"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>
          <when value="omni">
              <param format="vcf" label="ROD file" name="input_rod" type="data"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>
          <when value="indels">
              <param format="vcf" label="ROD file" name="input_rod" type="data"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>
          <when value="custom">
              <param label="ROD Name" name="custom_rod_name" type="text" value="Unknown"/>
              <param format="vcf" label="ROD file" name="input_rod" type="data"/>
              <conditional name="rod_training_type">
                  <param label="Use as training/truth/known sites" name="rod_training_type_selector" type="select">
                      <option value="is_training_truth_known">Set training/truth/known sites</option>
                      <option selected="True" value="not_training_truth_known">Don't Set options</option>
                  </param>
                  <when value="not_training_truth_known">
                      <!-- do nothing here -->
                  </when>
                  <when value="is_training_truth_known">
                      <param falsevalue="false" label="Is Known Site" name="known" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Training Site" name="training" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Truth Site" name="truth" truevalue="true" type="boolean"/>
                      <param falsevalue="false" label="Is Bad Site" name="bad" truevalue="true" type="boolean"/>
                      <param label="prior probability of being true" name="prior" type="float" value="12.0"/>
                  </when>
              </conditional>
          </when>
        </conditional>
    </repeat>
    
    <param display="checkboxes" help="-an,--use_annotation &amp;lt;use_annotation&amp;gt;" label="annotations which should used for calculations" multiple="True" name="annotations" type="select">
      <!-- load the available annotations from an external configuration file, since additional ones can be added to local installs -->
      <options from_data_table="gatk2_annotations">
        <filter column="tools_valid_for" separator="," type="multiple_splitter"/>
        <filter column="tools_valid_for" type="static_value" value="VariantRecalibrator"/>
      </options>
    </param>
    
    <repeat help="-an,--use_annotation &amp;lt;use_annotation&amp;gt;" name="additional_annotations" title="Additional annotation">
      <param label="Annotation name" name="additional_annotation_name" type="text" value=""/>
    </repeat>
    
    <param help="-mode,--mode &amp;lt;mode&amp;gt;" label="Recalibration mode" name="mode" type="select">
        <option selected="True" value="SNP">SNP</option>
        <option value="INDEL">INDEL</option>
        <option value="BOTH">BOTH</option>
    </param>
    
    <conditional name="gatk_param_type">
      <param label="Basic or Advanced GATK options" name="gatk_param_type_selector" type="select">
        <option selected="True" value="basic">Basic</option>
        <option value="advanced">Advanced</option>
      </param>
      <when value="basic">
        <!-- Do nothing here -->
      </when>
      <when value="advanced">
        <repeat help="-ped,--pedigree &amp;lt;pedigree&amp;gt;" name="pedigree" title="Pedigree file">
            <param format="txt" label="Pedigree files for samples" name="pedigree_file" type="data"/>
        </repeat>
        <repeat help="-pedString,--pedigreeString &amp;lt;pedigreeString&amp;gt;" name="pedigree_string_repeat" title="Pedigree string">
            <param label="Pedigree string for samples" name="pedigree_string" type="text" value=""/>
        </repeat>
        <param help="-pedValidationType,--pedigreeValidationType &amp;lt;pedigreeValidationType&amp;gt;" label="How strict should we be in validating the pedigree information" name="pedigree_validation_type" type="select">
          <option selected="True" value="STRICT">STRICT</option>
          <option value="SILENT">SILENT</option>
        </param>
        <repeat help="-rf,--read_filter &amp;lt;read_filter&amp;gt;" name="read_filter" title="Read Filter">
            <conditional name="read_filter_type">
              <param label="Read Filter Type" name="read_filter_type_selector" type="select">
                <option value="BadCigar">BadCigar</option>
                <option value="BadMate">BadMate</option>
                <option value="DuplicateRead">DuplicateRead</option>
                <option value="FailsVendorQualityCheck">FailsVendorQualityCheck</option>
                <option value="MalformedRead">MalformedRead</option>
                <option value="MappingQuality">MappingQuality</option>
                <option value="MappingQualityUnavailable">MappingQualityUnavailable</option>
                <option value="MappingQualityZero">MappingQualityZero</option>
                <option value="MateSameStrand">MateSameStrand</option>
                <option value="MaxInsertSize">MaxInsertSize</option>
                <option selected="True" value="MaxReadLength">MaxReadLength</option>
                <option value="MissingReadGroup">MissingReadGroup</option>
                <option value="NoOriginalQualityScores">NoOriginalQualityScores</option>
                <option value="NotPrimaryAlignment">NotPrimaryAlignment</option>
                <option value="Platform454">Platform454</option>
                <option value="Platform">Platform</option>
                <option value="PlatformUnit">PlatformUnit</option>
                <option value="ReadGroupBlackList">ReadGroupBlackList</option>
                <option value="ReadName">ReadName</option>
                <option value="ReadStrand">ReadStrand</option>
                <option value="ReassignMappingQuality">ReassignMappingQuality</option>
                <option value="Sample">Sample</option>
                <option value="SingleReadGroup">SingleReadGroup</option>
                <option value="UnmappedRead">UnmappedRead</option>
              </param>
              <when value="BadCigar">
                  <!-- no extra options -->
              </when>
              <when value="BadMate">
                  <!-- no extra options -->
              </when>
              <when value="DuplicateRead">
                  <!-- no extra options -->
              </when>
              <when value="FailsVendorQualityCheck">
                  <!-- no extra options -->
              </when>
              <when value="MalformedRead">
                  <param checked="false" falsevalue="" help="filter out the mismatch reads instead of quitting with an error" label="filter out the reads with mismatching number of bases and base qualities" name="filter_mismatching_base_and_quals" truevalue="--filter_mismatching_base_and_quals" type="boolean"/>
              </when>
              <when value="MappingQuality">
                  <param label="Minimum read mapping quality required to consider a read for calling" name="min_mapping_quality_score" type="integer" value="10"/>
              </when>
              <when value="MappingQualityUnavailable">
                  <!-- no extra options -->
              </when>
              <when value="MappingQualityZero">
                  <!-- no extra options -->
              </when>
              <when value="MateSameStrand">
                  <!-- no extra options -->
              </when>
              <when value="MaxInsertSize">
                  <param label="Discard reads with insert size greater than the specified value" name="maxInsertSize" type="integer" value="1000000"/>
              </when>
              <when value="MaxReadLength">
                  <param label="Max Read Length" name="maxReadLength" type="integer" value="76"/>
              </when>
              <when value="MissingReadGroup">
                  <!-- no extra options -->
              </when>
              <when value="NoOriginalQualityScores">
                  <!-- no extra options -->
              </when>
              <when value="NotPrimaryAlignment">
                  <!-- no extra options -->
              </when>
              <when value="Platform454">
                  <!-- no extra options -->
              </when>
              <when value="Platform">
                  <param label="Discard reads with RG:PL attribute containing this string" name="PLFilterName" type="text" value=""/>
              </when>
              <when value="PlatformUnit">
                  <!-- no extra options -->
              </when>
              <when value="ReadGroupBlackList">
                  <!-- no extra options -->
              </when>
              <when value="ReadName">
                  <param label="Filter out all reads except those with this read name" name="readName" type="text" value=""/>
              </when>
              <when value="ReadStrand">
                  <param falsevalue="" label="Discard reads on the forward strand" name="filterPositive" truevalue="--filterPositive" type="boolean"/>
              </when>
              <when value="ReassignMappingQuality">
                  <param label="Default read mapping quality to assign to all reads" name="default_mapping_quality" type="integer" value="60"/>
              </when>
              <when value="Sample">
                  <param label="The name of the sample(s) to keep, filtering out all others" name="sample_to_keep" type="text" value=""/>
              </when>
              <when value="SingleReadGroup">
                  <param label="The name of the read group to keep, filtering out all others" name="read_group_to_keep" type="integer" value="76"/>
              </when>
              <when value="UnmappedRead">
                  <!-- no extra options -->
              </when>
            </conditional>
        </repeat>
        <repeat help="-L,--intervals &amp;lt;intervals&amp;gt;" name="input_interval_repeat" title="Operate on Genomic intervals">
          <param format="bed,gatk_interval,picard_interval_list,vcf" label="Genomic intervals" name="input_intervals" type="data"/>
        </repeat>
        <repeat help="-XL,--excludeIntervals &amp;lt;excludeIntervals&amp;gt;" name="input_exclude_interval_repeat" title="Exclude Genomic intervals">
          <param format="bed,gatk_interval,picard_interval_list,vcf" label="Genomic intervals" name="input_exclude_intervals" type="data"/>
        </repeat>
        
        <param help="-isr,--interval_set_rule &amp;lt;interval_set_rule&amp;gt;" label="Interval set rule" name="interval_set_rule" type="select">
          <option selected="True" value="UNION">UNION</option>
          <option value="INTERSECTION">INTERSECTION</option>
        </param>
        
        <conditional name="downsampling_type">
          <param help="-dt,--downsampling_type &amp;lt;downsampling_type&amp;gt;" label="Type of reads downsampling to employ at a given locus" name="downsampling_type_selector" type="select">
            <option selected="True" value="NONE">NONE</option>
            <option value="ALL_READS">ALL_READS</option>
            <option value="BY_SAMPLE">BY_SAMPLE</option>
          </param>
          <when value="NONE">
              <!-- no more options here -->
          </when>
          <when value="ALL_READS">
              <conditional name="downsample_to_type">
                  <param label="Downsample method" name="downsample_to_type_selector" type="select">
                      <option selected="True" value="downsample_to_fraction">Downsample by Fraction</option>
                      <option value="downsample_to_coverage">Downsample by Coverage</option>
                  </param>
                  <when value="downsample_to_fraction">
                      <param help="-dfrac,--downsample_to_fraction &amp;lt;downsample_to_fraction&amp;gt;" label="Fraction [0.0-1.0] of reads to downsample to" max="1" min="0" name="downsample_to_value" type="float" value="1"/>
                  </when>
                  <when value="downsample_to_coverage">
                      <param help="-dcov,--downsample_to_coverage &amp;lt;downsample_to_coverage&amp;gt;" label="Coverage to downsample to at any given locus" name="downsample_to_value" type="integer" value="0"/>
                  </when>
              </conditional>
          </when>
          <when value="BY_SAMPLE">
              <conditional name="downsample_to_type">
                  <param label="Downsample method" name="downsample_to_type_selector" type="select">
                      <option selected="True" value="downsample_to_fraction">Downsample by Fraction</option>
                      <option value="downsample_to_coverage">Downsample by Coverage</option>
                  </param>
                  <when value="downsample_to_fraction">
                      <param help="-dfrac,--downsample_to_fraction &amp;lt;downsample_to_fraction&amp;gt;" label="Fraction [0.0-1.0] of reads to downsample to" max="1" min="0" name="downsample_to_value" type="float" value="1"/>
                  </when>
                  <when value="downsample_to_coverage">
                      <param help="-dcov,--downsample_to_coverage &amp;lt;downsample_to_coverage&amp;gt;" label="Coverage to downsample to at any given locus" name="downsample_to_value" type="integer" value="0"/>
                  </when>
              </conditional>
          </when>
        </conditional>
        <param help="-baq,--baq &amp;lt;baq&amp;gt;" label="Type of BAQ calculation to apply in the engine" name="baq" type="select">
          <option selected="True" value="OFF">OFF</option>
          <option value="CALCULATE_AS_NECESSARY">CALCULATE_AS_NECESSARY</option>
          <option value="RECALCULATE">RECALCULATE</option>
        </param>
        <param help="Default value is 40. 30 is perhaps better for whole genome call sets. -baqGOP,--baqGapOpenPenalty &amp;lt;baqGapOpenPenalty&amp;gt;" label="BAQ gap open penalty (Phred Scaled)" name="baq_gap_open_penalty" type="float" value="40"/>
        <param falsevalue="" help="-OQ,--useOriginalQualities" label="Use the original base quality scores from the OQ tag" name="use_original_qualities" truevalue="--useOriginalQualities" type="boolean"/>
        <param help="-DBQ,--defaultBaseQualities &amp;lt;defaultBaseQualities&amp;gt;" label="Value to be used for all base quality scores, when some are missing" name="default_base_qualities" type="integer" value="-1"/>
        <param help="-S,--validation_strictness &amp;lt;validation_strictness&amp;gt;" label="How strict should we be with validation" name="validation_strictness" type="select">
          <option selected="True" value="STRICT">STRICT</option>
          <option value="LENIENT">LENIENT</option>
          <option value="SILENT">SILENT</option>
          <!-- <option value="DEFAULT_STRINGENCY">DEFAULT_STRINGENCY</option> listed in docs, but not valid value...-->
        </param>
        <param help="-im,--interval_merging &amp;lt;interval_merging&amp;gt;" label="Interval merging rule" name="interval_merging" type="select">
          <option selected="True" value="ALL">ALL</option>
          <option value="OVERLAPPING_ONLY">OVERLAPPING_ONLY</option>
        </param>
        
        <repeat help="-rgbl,--read_group_black_list &amp;lt;read_group_black_list&amp;gt;" name="read_group_black_list_repeat" title="Read group black list">
          <conditional name="read_group_black_list_type">
            <param label="Type of reads read group black list" name="read_group_black_list_type_selector" type="select">
              <option selected="True" value="file">Filters in file</option>
              <option value="text">Specify filters as a string</option>
            </param>
            <when value="file">
              <param format="txt" label="Read group black list file" name="read_group_black_list" type="data"/>
            </when>
            <when value="text">
              <param label="Read group black list tag:string" name="read_group_black_list" type="text" value="tag:string"/>
            </when>
          </conditional>
        </repeat>
        
        <param checked="False" falsevalue="" help="--disable_experimental_low_memory_sharding" label="Disable experimental low-memory sharding functionality." name="disable_experimental_low_memory_sharding" truevalue="--disable_experimental_low_memory_sharding" type="boolean"/>
        <param checked="False" falsevalue="" help="-ndrs,--nonDeterministicRandomSeed" label="Makes the GATK behave non deterministically, that is, the random numbers generated will be different in every run" name="non_deterministic_random_seed" truevalue="--nonDeterministicRandomSeed" type="boolean"/>
        <param checked="False" falsevalue="" help="-fixMisencodedQuals / --fix_misencoded_quality_scores" label="Fix mis-encoded base quality scores. Q0 equal to ASCII 33 according to the SAM specification, whereas Illumina encoding starts at Q64. The idea here is simple: we just iterate over all reads and subtract 31 from every quality score." name="fix_misencoded_quality_scores" truevalue="--fix_misencoded_quality_scores" type="boolean"/>
        
      </when>
    </conditional>
    
    <conditional name="analysis_param_type">
      <param label="Basic or Advanced Analysis options" name="analysis_param_type_selector" type="select">
        <option selected="True" value="basic">Basic</option>
        <option value="advanced">Advanced</option>
      </param>
      <when value="basic">
        <!-- Do nothing here -->
      </when>
      <when value="advanced">
        <param help="-mG,--maxGaussians &amp;lt;maxGaussians&amp;gt;" label="maximum number of Gaussians to try during variational Bayes Algorithm" name="max_gaussians" type="integer" value="10"/>
        <param help="-mI,--maxIterations &amp;lt;maxIterations&amp;gt;" label="maximum number of maximum number of VBEM iterations to be performed in variational Bayes Algorithm" name="max_iterations" type="integer" value="100"/>
        <param help="-nKM,--numKMeans &amp;lt;numKMeans&amp;gt;" label="number of k-means iterations to perform in order to initialize the means of the Gaussians in the Gaussian mixture model" name="num_k_means" type="integer" value="30"/>
        <param help="-std,--stdThreshold &amp;lt;stdThreshold&amp;gt;" label="If a variant has annotations more than -std standard deviations away from mean then don't use it for building the Gaussian mixture model." name="std_threshold" type="float" value="8.0"/>
        <param help="-qual,--qualThreshold &amp;lt;qualThreshold&amp;gt;" label="If a known variant has raw QUAL value less than -qual then don't use it for building the Gaussian mixture model." name="qual_threshold" type="float" value="80.0"/>
        <param help="-shrinkage,--shrinkage &amp;lt;shrinkage&amp;gt;" label="shrinkage parameter in variational Bayes algorithm" name="shrinkage" type="float" value="1.0"/>
        <param help="-dirichlet,--dirichlet &amp;lt;dirichlet&amp;gt;" label="dirichlet parameter in variational Bayes algorithm" name="dirichlet" type="float" value="0.001"/>
        <param help="-priorCounts,--priorCounts &amp;lt;priorCounts&amp;gt;" label="number of prior counts to use in variational Bayes algorithm" name="prior_counts" type="float" value="20.0"/>
        <conditional name="bad_variant_selector">
          <param label="How to specify bad variants" name="bad_variant_selector_type" type="select">
            <option selected="True" value="percent">Percent</option>
            <option value="min_num">Number</option>
          </param>
          <when value="percent">
            <param help="-percentBad,--percentBadVariants &amp;lt;percentBadVariants&amp;gt;" label="percentage of the worst scoring variants to use when building the Gaussian mixture model of bad variants. 0.07 means bottom 7 percent." name="percent_bad_variants" type="float" value="0.03"/>
          </when>
          <when value="min_num">
            <param help="-minNumBad,--minNumBadVariants &amp;lt;minNumBadVariants&amp;gt;" label="minimum amount of worst scoring variants to use when building the Gaussian mixture model of bad variants. Will override -percentBad arugment if necessary" name="min_num_bad_variants" type="integer" value="2000"/>
          </when>
        </conditional>
        <param help="-titv,--target_titv &amp;lt;target_titv&amp;gt;" label="expected novel Ti/Tv ratio to use when calculating FDR tranches and for display on optimization curve output figures. (approx 2.15 for whole genome experiments). ONLY USED FOR PLOTTING PURPOSES!" name="target_titv" type="float" value="2.15"/>
        <param help="-tranche,--TStranche &amp;lt;TStranche&amp;gt;" label="levels of novel false discovery rate (FDR, implied by ti/tv) at which to slice the data. (in percent, that is 1.0 for 1 percent)" name="ts_tranche" type="text" value="100.0, 99.9, 99.0, 90.0"/>
        <repeat help="-ignoreFilter,--ignore_filter &amp;lt;ignore_filter&amp;gt;" name="ignore_filters" title="Ignore Filter">
          <conditional name="ignore_filter_type">
            <param label="Filter Type" name="ignore_filter_type_selector" type="select">
              <option value="HARD_TO_VALIDATE">HARD_TO_VALIDATE</option>
              <option value="LowQual">LowQual</option>
              <option selected="True" value="custom">Other</option>
            </param>
            <when value="custom">
              <param label="Filter name" name="filter_name" type="text" value=""/>
            </when>
            <when value="HARD_TO_VALIDATE"/>
            <when value="LowQual"/>
          </conditional>
        </repeat>
        <param help="-ts_filter_level,--ts_filter_level &amp;lt;ts_filter_level&amp;gt;" label="truth sensitivity level at which to start filtering, used here to indicate filtered variants in plots" name="ts_filter_level" type="float" value="99.0"/>
      </when>
    </conditional>
  </inputs>
  <outputs>
    <data format="gatk_recal" label="${tool.name} on ${on_string} (Recalibration File)" name="output_recal"/>
    <data format="gatk_tranche" label="${tool.name} on ${on_string} (Tranches File)" name="output_tranches"/>
    <data format="txt" label="${tool.name} on ${on_string} (RScript File)" name="output_rscript"/>
    <data format="pdf" label="${tool.name} on ${on_string} (PDF File)" name="output_tranches_pdf"/>
    <data format="txt" label="${tool.name} on ${on_string} (log)" name="output_log"/>
  </outputs>
  <tests>
      <!-- ADD TESTS -->
  </tests>
  <help>
**What it does**

Takes variant calls as .vcf files, learns a Gaussian mixture model over the variant annotations and evaluates the variant -- assigning an informative lod score

For more information on using the VariantRecalibrator module, see this `tool specific page &lt;http://www.broadinstitute.org/gatk/gatkdocs/org_broadinstitute_sting_gatk_walkers_variantrecalibration_VariantRecalibrator.html&gt;`_.

To learn about best practices for variant detection using GATK, see this `overview &lt;http://www.broadinstitute.org/gatk/guide/topic?name=best-practices&gt;`_.

If you encounter errors, please view the `GATK FAQ &lt;http://www.broadinstitute.org/gatk/guide/topic?name=faqs&gt;`_.

------

**Inputs**

GenomeAnalysisTK: VariantRecalibrator accepts a variant input file.


**Outputs**

The output is in VCF format.


Go `here &lt;http://www.broadinstitute.org/gatk/guide/topic?name=intro&gt;`_ for details on GATK file formats.

-------

**Settings**::


 tranches_file         The output tranches file used by ApplyRecalibration
 use_annotation        The names of the annotations which should used for calculations
 mode                  Recalibration mode to employ: 1.) SNP for recalibrating only snps (emitting indels untouched in the output VCF); 2.) INDEL for indels; and 3.) BOTH for recalibrating both snps and indels simultaneously. (SNP|INDEL|BOTH)
 maxGaussians          The maximum number of Gaussians to try during variational Bayes algorithm
 maxIterations         The maximum number of VBEM iterations to be performed in variational Bayes algorithm. Procedure will normally end when convergence is detected.
 numKMeans             The number of k-means iterations to perform in order to initialize the means of the Gaussians in the Gaussian mixture model.
 stdThreshold          If a variant has annotations more than -std standard deviations away from mean then don't use it for building the Gaussian mixture model.
 qualThreshold         If a known variant has raw QUAL value less than -qual then don't use it for building the Gaussian mixture model.
 shrinkage             The shrinkage parameter in variational Bayes algorithm.
 dirichlet             The dirichlet parameter in variational Bayes algorithm.
 priorCounts           The number of prior counts to use in variational Bayes algorithm.
 percentBadVariants    What percentage of the worst scoring variants to use when building the Gaussian mixture model of bad variants. 0.07 means bottom 7 percent.
 minNumBadVariants     The minimum amount of worst scoring variants to use when building the Gaussian mixture model of bad variants. Will override -percentBad arugment if necessary.
 recal_file            The output recal file used by ApplyRecalibration
 target_titv           The expected novel Ti/Tv ratio to use when calculating FDR tranches and for display on optimization curve output figures. (approx 2.15 for whole genome experiments). ONLY USED FOR PLOTTING PURPOSES!
 TStranche             The levels of novel false discovery rate (FDR, implied by ti/tv) at which to slice the data. (in percent, that is 1.0 for 1 percent)
 ignore_filter         If specified the optimizer will use variants even if the specified filter name is marked in the input VCF file
 path_to_Rscript       The path to your implementation of Rscript. For Broad users this is maybe /broad/tools/apps/R-2.6.0/bin/Rscript
 rscript_file          The output rscript file generated by the VQSR to aid in visualization of the input data and learned model
 path_to_resources     Path to resources folder holding the Sting R scripts.
 ts_filter_level       The truth sensitivity level at which to start filtering, used here to indicate filtered variants in plots

------

**Citation**

For the underlying tool, please cite `DePristo MA, Banks E, Poplin R, Garimella KV, Maguire JR, Hartl C, Philippakis AA, del Angel G, Rivas MA, Hanna M, McKenna A, Fennell TJ, Kernytsky AM, Sivachenko AY, Cibulskis K, Gabriel SB, Altshuler D, Daly MJ. A framework for variation discovery and genotyping using next-generation DNA sequencing data. Nat Genet. 2011 May;43(5):491-8. &lt;http://www.ncbi.nlm.nih.gov/pubmed/21478889&gt;`_

Please also site `McKenna A, Hanna M, Banks E, Sivachenko A, Cibulskis K, Kernytsky A, Garimella K, Altshuler D, Gabriel S, Daly M, DePristo MA (2010). The Genome Analysis Toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data. Genome Res. 20:1297-303. Epub 2010 Jul 19. &lt;http://www.ncbi.nlm.nih.gov/pubmed/20644199&gt;`_

If you use this tool in Galaxy, please cite `Blankenberg D, Von Kuster G, Coraor N, Ananda G, Lazarus R, Mangan M, Nekrutenko A, Taylor J. Galaxy: a web-based genome analysis tool for experimentalists. Curr Protoc Mol Biol. 2010 Jan;Chapter 19:Unit 19.10.1-21. &lt;http://www.ncbi.nlm.nih.gov/pubmed/20069535&gt;`_

  </help>
</tool>