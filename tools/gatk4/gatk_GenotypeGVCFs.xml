<tool id="gatk4_GenotypeGVCFs" name="GenotypeGVCFs" version="GATK4: GenomeAnalysisTK-4; SAMTOOLS: 1.1">
  <description>Perform joint genotyping on one or more samples pre-called with HaplotypeCaller</description>
  <requirements>
      <requirement type="package" version="gatk-4.0.5.0">gatk4</requirement>
      <requirement type="package" version="1.1">samtools</requirement>
      <requirement type="package" version="1.8.0">java</requirement>
  </requirements>
  <macros>
    <import>gatk_macros.xml</import>
  </macros>
  <command interpreter="python">gatk_wrapper.py
   --max_jvm_heap_fraction "1"
   #if str( $reference_source.input_bam ) != "None":
     -d "-I" "${reference_source.input_bam}" "${reference_source.input_bam.ext}" "gatk_input"
     #if str( $reference_source.input_bam.metadata.bam_index ) != "None":
       -d "" "${reference_source.input_bam.metadata.bam_index}" "bam_index" "gatk_input" ##hardcode galaxy ext type as bam_index
     #end if
   #end if
   #if str($reference_source.reference_source_selector) == "cached":
     #for $i, $input_format in enumerate( $reference_source.input_variants ):
       #if str($input_format.input_format_selector.input_format) == "galaxy":
         -d "--variant" "${input_format.input_format_selector.input_variant}" "${input_format.input_format_selector.input_variant.ext}" "input_format_${i}"
       #else:
         #import os, glob
         #if str($input_format.input_format_selector.input_format) == "swift":
           #set $variant_files = glob.glob(str( $input_format.input_format_selector.swift_input_file.extra_files_path) + "/*.vcf"  )
         #else:
           #set $variant_files = glob.glob(str( $input_format.input_format_selector.ref_vcf_file.fields.path) + "/*/*.vcf"  )
         #end if
         #set $i = 0
         #for $input_variant in $variant_files:
           #set $variant_ext = "vcf"
           -d "-V" "$input_variant" "$variant_ext" "input_variant_set_${i}"
           #set $i = $i + 1
         #end for
       #end if
     #end for
   #end if
   -t "GenotypeGVCFs --sparkRunner LOCAL "
   -p '
    #if $reference_source.reference_source_selector != "history":
        -R "${reference_source.ref_file.fields.path}"
    #end if
    --output "${output_vcf}"
    '
    
    ##start standard gatk options
    ###if $gatk_param_type.gatk_param_type_selector == "advanced":
    ##    #include source=$standard_gatk_options#
    ###end if
    
    #if str( $reference_source.reference_source_selector ) == "history":
        -d "-R" "${reference_source.ref_file}" "${reference_source.ref_file.ext}" "gatk_input_reference_fasta"
        --picard_jar "/mnt/galaxyTools/tools/picard/1.121/CreateSequenceDictionary.jar"
    #end if
    
    ## start tool specific options
    #if $tool_param_type.param_type_selector == "advanced":
      -p ' $tool_param_type.annotateNDA ' 
      -p ' $tool_param_type.useNewAFCalculator '
      #if str( $tool_param_type.annotation ) != "None":
        #for $annotation in str( $tool_param_type.annotation.fields.gatk_value ).split( ','):
          -p ' --annotation ${annotation} '
        #end for
      #end if
      #for $additional_annotation in $tool_param_type.additional_annotations:
        -p ' --annotation ${additional_annotation.additional_annotation_name} '
      #end for
      #if str( $tool_param_type.group ) != "None":
        #for $group in str( $tool_param_type.group ).split( ','):
          -p ' --group "${group}" '
        #end for
      #end if
      #if str( $tool_param_type.exclude_annotations ) != "None":
        #for $annotation in str( $tool_param_type.exclude_annotations.fields.gatk_value ).split( ','):
          -p ' --annotationsToExclude "${annotation}" '
        #end for
      #end if
      #if str($tool_param_type.dbsnp) != 'None':
        -p ' --dbsnp $tool_param_type.dbsnp '
      #end if
      #if $tool_param_type.heterozygosity.__str__.strip() != '0.0010':
        -p ' --heterozygosity $tool_param_type.heterozygosity '
      #end if
      #if $tool_param_type.indel_heterozygosity.__str__.strip() != "0.000125":
        -p ' --indel_heterozygosity ${tool_param_type.indel_heterozygosity}'
      #end if

      #if $tool_param_type.standard_min_confidence_threshold_for_calling.__str__.strip() != '30.0':
        --standard_min_confidence_threshold_for_calling $tool_param_type.standard_min_confidence_threshold_for_calling
      #end if
      #if $tool_param_type.max_alternate_alleles.__str__.strip() != '6':
        -p ' --max_alternate_alleles $tool_param_type.max_alternate_alleles '
      #end if
      #if $tool_param_type.max_genotype_count.__str__.strip() != '1024':
        -p ' --max_genotype_count $tool_param_type.max_genotype_count '
      #end if
      #if str( $tool_param_type.sample_ploidy ) != '2':
        -p ' --sample_ploidy $tool_param_type.sample_ploidy '
      #end if
      #if $tool_param_type.extra_params.__str__.strip() != "":
        -p ' $tool_param_type.extra_params '
      #end if
    #end if

    ##start gatk general options
    #if $analysis_param_type.analysis_param_type_selector == "advanced":
        -p '
        --addOutputSAMProgramRecord --addOutputVCFCommandLine
        #if str($analysis_param_type.cloudIndexPrefetchBuffer) != "-1":
          --cloudIndexPrefetchBuffer ${analysis_param_type.cloudIndexPrefetchBuffer}
        #end if
        #if str($analysis_param_type.cloudPrefetchBuffer) != "40":
          --cloudPrefetchBuffer ${analysis_param_type.cloudPrefetchBuffer}
        #end if
        #for $filter in str( $analysis_param_type.disableReadFilter ).split(','):
          #if $filter != "None"
            --disableReadFilter $filter
          #end if
        #end for
        $analysis_param_type.disableSequenceDictionaryValidation
        $analysis_param_type.disableToolDefaultReadFilters
        #if str( $analysis_param_type.gcs_max_retries ) != "20"
          --gcs_max_retries ${analysis_param_type.gcs_max_retries}
        #end if
        #if str( $analysis_param_type.interval_exclusion_padding ) != "0"
          --interval_exclusion_padding ${analysis_param_type.interval_exclusion_padding}
        #end if
        #if str( $analysis_param_type.interval_merging_rule ) != "ALL"
          --interval_merging_rule ${analysis_param_type.interval_merging_rule}
        #end if
        #if str( $analysis_param_type.interval_padding ) != "0"
          --interval_padding ${analysis_param_type.interval_padding}
        #end if
        #if str( $analysis_param_type.interval_set_rule ) != "UNION"
          --interval_set_rule ${analysis_param_type.interval_set_rule}
        #end if
        $analysis_param_type.lenient
        #set default_read_filters = ["WellformedReadFilter"]
        #for $read_filter in $analysis_param_type.read_filter:
          #if $read_filter.read_filter_type.read_filter_type_selector not in $default_read_filters:
            --read_filter ${read_filter.read_filter_type.read_filter_type_selector}
            #if $read_filter.read_filter_type.read_filter_type_selector == "AmbiguousBaseReadFilter"
              #if $read_filter.read_filter_type.AmbiguousBaseReadFilter_type.AmbiguousBaseReadFilter_type_select == "number":
                --ambigFilterBases $read_filter.read_filter_type.AmbiguousBaseReadFilter_type.ambigFilterBases
              #else
                --ambigFilterBases $read_filter.read_filter_type.AmbiguousBaseReadFilter_type.ambigFilterFrac
              #end if
            #else
              #for $name, $param in $read_filter.read_filter_type.iteritems():
                #if $name not in [ "__current_case__", "read_filter_type_selector" ]:
                    #if hasattr( $param.input, 'truevalue' ):
                        ${param}
                    #else:
                        --${name} ${param}
                    #end if
                #end if
              #end for
            #end if
          #end if
        #end for
        #if str($analysis_param_type.readValidationStringency) != "SILENT"
          --readValidationStringency $analysis_param_type.readValidationStringency
        #end if
        '
        #for $interval_count, $input_intervals in enumerate( $analysis_param_type.input_interval_repeat ):
            -d "--intervals" "${input_intervals.input_intervals}" "${input_intervals.input_intervals.ext}" "input_intervals_${interval_count}"
        #end for
        #for $interval_count, $input_intervals in enumerate( $analysis_param_type.input_exclude_interval_repeat ):
            -d "--excludeIntervals" "${input_intervals.input_exclude_intervals}" "${input_intervals.input_exclude_intervals.ext}" "input_exlude_intervals_${interval_count}"
        #end for
    #end if
  </command>
  <inputs>
    <conditional name="reference_source">
      <param label="Choose the source for the reference list" name="reference_source_selector" type="select">
        <option value="cached">Locally cached</option>
        <option value="history">History</option>
      </param>
      <when value="cached">
        <param format="bam" help="-I,--input_file &amp;lt;input_file&amp;gt;" label="BAM file" name="input_bam" type="data" optional="true"/>
        <repeat help="Records will be prioritized in the order that you list them here (-V,-\-variant &amp;lt;variant&amp;gt;)" min="1" name="input_variants" title="Variants to Merge">
          <conditional name="input_format_selector">
            <param help="You can specify VCF files in this history or provide a file that points to a directory where VCFs are." label="How will you provide inputs" name="input_format" type="select">
              <option selected="true" value="galaxy">VCF files are in the history</option>
              <option value="swift">File output from Swift</option>
              <option value="reference">Use VCF from reference set</option>
            </param>
            <when value="galaxy">
              <param format="vcf" label="Input variant file" name="input_variant" type="data" help="-V,--variant &amp;lt;variant&amp;gt;"/>
            </when>
            <when value="swift">
              <param help="Must be in tabular format with column VCF separated by tab and its value." label="Input file containing path to VCF files" name="swift_input_file" type="data"/>
            </when>
            <when value="reference">
              <param help="VCFs are stored in a set to be used" label="Select a reference VCF list" name="ref_vcf_file" type="select">
                <options from_data_table="gatk3_reference_vcf_set">
                </options>
              </param>
            </when>
          </conditional>
        </repeat>
        <param help="-R,--reference_sequence &amp;lt;reference_sequence&amp;gt;" label="Using reference genome" name="ref_file" type="select">
          <options from_data_table="gatk3_picard_indexes">
            <!-- <filter type="data_meta" key="dbkey" ref="input_variants.input_variant" column="dbkey"/> -->
          </options>
          <validator message="A built-in reference genome is not available for the build associated with the selected input file" type="no_options"/>
        </param>
      </when>
      <when value="history"> <!-- FIX ME!!!! -->
        <param format="bam" help="-I,--input_file &amp;lt;input_file&amp;gt;" label="BAM file" name="input_bam" type="data"/>
        <repeat help="Records will be prioritized in the order that you list them here (-V,--variant &amp;lt;variant&amp;gt;)" min="1" name="input_variants" title="Variants to Merge">
          <conditional name="input_format_selector">
            <param help="You can specify VCF files in this history or provide a file that points to a directory where VCFs are." label="How will you provide inputs" name="input_format" type="select">
              <option selected="true" value="galaxy">VCF files are in the history</option>
              <option value="swift">File output from Swift</option>
              <option value="reference">Use VCF from reference set</option>
            </param>
            <when value="galaxy">
              <param format="vcf" label="Input variant file" name="input_variant" type="data"/>
            </when>
            <when value="swift">
              <param help="Must be in tabular format with column VCF separated by tab and its value." label="Input file containing path to VCF files" name="swift_input_file" type="data"/>
            </when>
            <when value="reference">
              <param help="VCFs are stored in a set to be used" label="Select a reference VCF list" name="ref_vcf_file" type="select">
                <options from_data_table="gatk3_reference_vcf_set">
                </options>
              </param>
            </when>
          </conditional>
        </repeat>
        <param format="fasta" help="-R,--reference_sequence &amp;lt;reference_sequence&amp;gt;" label="Using reference file" name="ref_file" type="data"/>
      </when>
    </conditional>

    <conditional name="tool_param_type">
      <param label="Basic or Advanced tool options" name="param_type_selector" type="select">
        <option selected="True" value="basic">Basic</option>
        <option value="advanced">Advanced</option>
      </param>
      <when value="basic"></when>
      <when value="advanced">
        <!--<expand macro="advanced_options" />-->
        <param display="checkboxes" help="-A,--annotation &amp;lt;annotation&amp;gt;" label="Annotation Types" multiple="True" name="annotation" type="select">
          <!-- load the available annotations from an external configuration file, since additional ones can be added to local installs -->
          <options from_data_table="gatk3_annotations">
            <filter column="tools_valid_for" separator="," type="multiple_splitter"/>
            <filter column="tools_valid_for" type="static_value" value="UnifiedGenotyper"/>
          </options>
        </param>
        <repeat help="-A,--annotation &amp;lt;annotation&amp;gt;" name="additional_annotations" title="Additional annotation">
          <param label="Annotation name" name="additional_annotation_name" type="text" value=""/>
        </repeat>
        <param display="checkboxes" help="-G,--group &amp;lt;group&amp;gt;" label="Annotation Interfaces/Groups" multiple="True" name="group" type="select">
          <option value="RodRequiringAnnotation">RodRequiringAnnotation</option>
          <option value="Standard">Standard</option>
          <option value="Experimental">Experimental</option>
          <option value="WorkInProgress">WorkInProgress</option>
          <option value="RankSumTest">RankSumTest</option>
          <!--<option value="none">none</option> -->
        </param>
    <!--     <param name="family_string" type="text" value="" label="Family String"/> -->
        <param display="checkboxes" help="-AX,--annotationsToExclude &amp;lt;annotationsToExclude&amp;gt;" label="Annotations to exclude" multiple="True" name="exclude_annotations" type="select">
          <!-- load the available annotations from an external configuration file, since additional ones can be added to local installs -->
          <options from_data_table="gatk3_annotations">
            <filter column="tools_valid_for" separator="," type="multiple_splitter"/>
            <filter column="tools_valid_for" type="static_value" value="UnifiedGenotyper"/>
          </options>
        </param>
        <param format="vcf" help="--dbsnp / -D  dbSNP file" label="dbsnp" name="dbsnp" optional="true" type="data"/>
        <param help="--heterozygosity / -hets  Heterozygosity value used to compute prior likelihoods for any locus" label="heterozygosity" name="heterozygosity" optional="true" type="float" value="0.0010"/>
        <param help="1.0/8000==0.000125 (-indelHeterozygosity,--indel_heterozygosity &amp;lt;indel_heterozygosity&amp;gt;)" label="Heterozygosity for indel calling" name="indel_heterozygosity" type="float" value="0.000125"/>
        <param help="--standard_min_confidence_threshold_for_calling / -stand_call_conf  The minimum phred-scaled confidence threshold at which variants should be called" label="standard_min_confidence_threshold_for_calling" name="standard_min_confidence_threshold_for_calling" optional="true" type="float" value="30.0"/>
        <param help="--max_alternate_alleles / -maxAltAlleles  Maximum number of alternate alleles to genotype" label="max_alternate_alleles" name="max_alternate_alleles" optional="true" type="integer" value="6"/>
        <param help="--max_genotype_count / -maxGT  Maximum number of genotypes to consider at any site" label="Maximum genotype_count" name="max_genotype_count" optional="true" type="integer" value="1024"/>
        <param help="--sample_ploidy / -ploidy (default value 2 ). For pooled data, set to (Number of samples in each pool * Sample Ploidy)." label="Ploidy (number of chromosomes) per sample." name="sample_ploidy" optional="true" type="integer" value="2"/>
        <param label="Include these additional parameters not shown in interface" name="extra_params" type="text" value=""/>
        <param checked="false" falsevalue="" help="--annotateNDA / -nda &amp;lt;annotateNDA&amp;gt;: If provided, we will annotate records with the number of alternate alleles that were discovered (but not necessarily genotyped) at a given site" label="Annotate Number of discovered alleles" name="annotateNDA" truevalue="--annotateNDA" type="boolean"/>
        <param checked="false" falsevalue="" help="--useNewAFCalculator / -newQual &amp;lt;useNewAFCalculator&amp;gt;: Use the new AF model instead of the so-called exact model" label="Use New AF Calculator" name="useNewAFCalculator" truevalue="--useNewAFCalculator" type="boolean"/>
      </when>
    </conditional>
    
    <conditional name="analysis_param_type">
      <param label="Basic or Advanced Analysis options" name="analysis_param_type_selector" type="select">
        <option selected="True" value="basic">Basic</option>
        <option value="advanced">Advanced</option>
      </param>
      <when value="basic"></when>
      <when value="advanced">
        <param help="Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. -CIPB,--cloudIndexPrefetchBuffer &amp;lt;cloudIndexPrefetchBuffer&amp;gt;" label="Cloud Index Prefetch Buffer" name="cloudIndexPrefetchBuffer" type="text" value="-1"/>
        <param help="Size of the cloud-only prefetch buffer (in MB; 0 to disable). -CPB,--cloudPrefetchBuffer &amp;lt;cloudPrefetchBuffer&amp;gt;" label="Cloud Prefetch Buffer" name="cloudPrefetchBuffer" type="integer" value="40"/>
        <param help="-gcs_retries,--gcs_max_retries &amp;lt;gcs_max_retries&amp;gt;: If the GCS bucket channel errors out, how many times it will attempt to re-initiate the connection." label="GCS max retries" name="gcs_max_retries" type="integer" value="20"/>
        <param help="-ixp,--interval_exclusion_padding &amp;lt;interval_exclusion_padding&amp;gt;: Amount of padding (in bp) to add to each interval you are excluding." label="Interval Exclusion Padding" name="interval_exclusion_padding" type="integer" value="0"/>
        <param help="--interval_merging_rule,-imr &amp;lt;interval_merging_rule&amp;gt;: Interval merging rule for abutting intervals." label="Interval merging rule" name="interval_merging_rule" type="select">
          <option value="ALL" selected="true">ALL</option>
          <option value="OVERLAPPING_ONLY">OVERLAPPING_ONLY</option>
        </param>
        <param help="-ip,--interval_padding &amp;lt;interval_padding&amp;gt;: Amount of padding (in bp) to add to each interval you are including." label="Interval Padding" name="interval_padding" type="integer" value="0"/>
        <param help="--interval_set_rule,-isr &amp;lt;interval_set_rule&amp;gt;: Set merging approach to use for combining interval inputs." label="Interval set rule" name="interval_set_rule" type="select">
          <option value="UNION" selected="true">UNION</option>
          <option value="INTERSECTION">INTERSECTION</option>
        </param>
        <repeat help="-L,--intervals &amp;lt;intervals&amp;gt;" name="input_interval_repeat" title="Operate on Genomic intervals">
          <param format="bed,gatk_interval,picard_interval_list,vcf" label="Genomic intervals" name="input_intervals" type="data"/>
        </repeat>
        <repeat help="-XL,--excludeIntervals &amp;lt;excludeIntervals&amp;gt;" name="input_exclude_interval_repeat" title="Exclude Genomic intervals">
          <param format="bed,gatk_interval,picard_interval_list,vcf" label="Genomic intervals" name="input_exclude_intervals" type="data"/>
        </repeat>
        <repeat help="-rf,--read_filter &amp;lt;read_filter&amp;gt;" name="read_filter" title="Read Filter">
            <conditional name="read_filter_type">
              <param label="Read Filter Type" name="read_filter_type_selector" type="select">
                <option value="AlignmentAgreesWithHeaderReadFilter">AlignmentAgreesWithHeaderReadFilter</option>
                <option value="AllowAllReadsReadFilter">AllowAllReadsReadFilter</option>
                <option value="AmbiguousBaseReadFilter">AmbiguousBaseReadFilter</option>
                <option value="CigarContainsNoNOperator">CigarContainsNoNOperator</option>
                <option value="FirstOfPairReadFilter">FirstOfPairReadFilter</option>
                <option value="FragmentLengthReadFilter">FragmentLengthReadFilter</option>
                <option value="GoodCigarReadFilter">GoodCigarReadFilter</option>
                <option value="HasReadGroupReadFilter">HasReadGroupReadFilter</option>
                <option value="LibraryReadFilter">LibraryReadFilter</option>
                <option value="MappedReadFilter">MappedReadFilter</option>
                <option value="MappingQualityAvailableReadFilter">MappingQualityAvailableReadFilter</option>
                <option value="MappingQualityNotZeroReadFilter">MappingQualityNotZeroReadFilter</option>
                <option value="MappingQualityReadFilter">MappingQualityReadFilter</option>
                <option value="MatchingBasesAndQualsReadFilter">MatchingBasesAndQualsReadFilter</option>
                <option value="MateDifferentStrandReadFilter">MateDifferentStrandReadFilter</option>
                <option value="MateOnSameContigOrNoMappedMateReadFilter">MateOnSameContigOrNoMappedMateReadFilter</option>
                <option value="MetricsReadFilter">MetricsReadFilter</option>
                <option value="NonZeroFragmentLengthReadFilter">NonZeroFragmentLengthReadFilter</option>
                <option value="NonZeroReferenceLengthAlignmentReadFilter">NonZeroReferenceLengthAlignmentReadFilter</option>
                <option value="NotDuplicateReadFilter">NotDuplicateReadFilter</option>
                <option value="NotSecondaryAlignmentReadFilter">NotSecondaryAlignmentReadFilter</option>
                <option value="NotSupplementaryAlignmentReadFilter">NotSupplementaryAlignmentReadFilter</option>
                <option value="OverclippedReadFilter">OverclippedReadFilter</option>
                <option value="PairedReadFilter">PairedReadFilter</option>
                <option value="PassesVendorQualityCheckReadFilter">PassesVendorQualityCheckReadFilter</option>
                <option value="PlatformReadFilter">PlatformReadFilter</option>
                <option value="PlatformUnitReadFilter">PlatformUnitReadFilter</option>
                <option value="PrimaryAlignmentReadFilter">PrimaryAlignmentReadFilter</option>
                <option value="ProperlyPairedReadFilter">ProperlyPairedReadFilter</option>
                <option value="ReadGroupBlackListReadFilter">ReadGroupBlackListReadFilter</option>
                <option value="ReadGroupReadFilter">ReadGroupReadFilter</option>
                <option value="ReadLengthEqualsCigarLengthReadFilter">ReadLengthEqualsCigarLengthReadFilter</option>
                <option value="ReadLengthReadFilter">ReadLengthReadFilter</option>
                <option value="ReadNameReadFilter">ReadNameReadFilter</option>
                <option value="ReadStrandFilter">ReadStrandFilter</option>
                <option value="SampleReadFilter">SampleReadFilter</option>
                <option value="SecondOfPairReadFilter">SecondOfPairReadFilter</option>
                <option value="SeqIsStoredReadFilter">SeqIsStoredReadFilter</option>
                <option value="ValidAlignmentEndReadFilter">ValidAlignmentEndReadFilter</option>
                <option value="ValidAlignmentStartReadFilter">ValidAlignmentStartReadFilter</option>
                <option value="WellformedReadFilter">WellformedReadFilter</option>
              </param>
              <when value="AlignmentAgreesWithHeaderReadFilter"></when>
              <when value="AllowAllReadsReadFilter"></when>
              <when value="AmbiguousBaseReadFilter">
                <conditional name="AmbiguousBaseReadFilter_type">
                  <param name="AmbiguousBaseReadFilter_type_select" type="select" label="Method to specify threshod">
                    <option value="number">Threshold number</option>
                    <option value="fraction" selected="true">Threshold fraction</option>
                  </param>
                  <when value="number">
                    <param help="--ambigFilterBases &amp;lt;ambigFilterBases&amp;gt;: Threshold number of ambiguous bases" label="Ambiguous Filter Bases" name="ambigFilterBases" type="integer" value="0"/>
                  </when>
                  <when value="fraction">
                    <param help="--ambigFilterFrac &amp;lt;ambigFilterFrac&amp;gt;: Threshold fraction of ambiguous bases" label="Ambiguous Filter Fraction" name="ambigFilterFrac" type="float" value="0.05"/>
                  </when>
                </conditional>
              </when>
              <when value="CigarContainsNoNOperator"></when>
              <when value="FirstOfPairReadFilter"></when>
              <when value="FragmentLengthReadFilter">
                <param label="Maximum Fragment length Read Filter" name="maxFragmentLength" type="integer" value="1000000" help="--maxFragmentLength,-maxFragmentLength &amp;lt;maxFragmentLength&amp;gt;: Keep only read pairs with fragment length at most equal to the given value"/>
              </when>
              <when value="GoodCigarReadFilter"></when>
              <when value="HasReadGroupReadFilter"></when>
              <when value="LibraryReadFilter">
                <param label="Library to keep" name="library" type="text" value="Enter value" help="--library,-library &amp;lt;maxFragmentLength&amp;gt;"/> 
              </when>
              <when value="MappedReadFilter"></when>
              <when value="MappingQualityAvailableReadFilter"></when>
              <when value="MappingQualityNotZeroReadFilter"></when>
              <when value="MappingQualityReadFilter">
                <param label="Minimum read mapping quality required to consider a read for calling" name="minimumMappingQuality" type="integer" value="10" help="--minimumMappingQuality,-minimumMappingQuality &amp;lt;minimumMappingQuality&amp;gt;"/>
                <param label="Maximum read mapping quality required to consider a read for calling" name="maximumMappingQuality" type="integer" value="1000" help="--maximumMappingQuality,-maximumMappingQuality &amp;lt;maximumMappingQuality&amp;gt;"/>
              </when>
              <when value="MatchingBasesAndQualsReadFilter"></when>
              <when value="MateDifferentStrandReadFilter"></when>
              <when value="MateOnSameContigOrNoMappedMateReadFilter"></when>
              <when value="MetricsReadFilter"></when>
              <when value="NonZeroFragmentLengthReadFilter"></when>
              <when value="NonZeroReferenceLengthAlignmentReadFilter"></when>
              <when value="NotDuplicateReadFilter"></when>
              <when value="NotSecondaryAlignmentReadFilter"></when>
              <when value="NotSupplementaryAlignmentReadFilter"></when>
              <when value="OverclippedReadFilter">
                <param checked="false" falsevalue="" help="--dontRequireSoftClipsBothEnds,-dontRequireSoftClipsBothEnds &amp;lt;dontRequireSoftClipsBothEnds&amp;gt;: Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block." label="Don't Require Soft Clips on Both Ends" name="dontRequireSoftClipsBothEnds" truevalue="--dontRequireSoftClipsBothEnds" type="boolean"/>
                <param label="Filter reads with less than this number of aligned bases" name="filterTooShort" type="integer" value="30" help="--filterTooShort,-filterTooShort &amp;lt;filterTooShort&amp;gt;"/>
              </when>
              <when value="PairedReadFilter"></when>
              <when value="PassesVendorQualityCheckReadFilter"></when>
              <when value="PlatformReadFilter">
                <param label="Keep reads with RG:PL attribute containing this string" name="PLFilterName" type="text" value="" help="--PLFilterName,-PLFilterName &amp;lt;PLFilterName&amp;gt;"/>
              </when>
              <when value="PlatformUnitReadFilter">
                <param label="Keep reads with platform units not in this list" name="blackListedLanes" type="text" value="" help="--blackListedLanes,-blackListedLanes &amp;lt;blackListedLanes&amp;gt;"/>
              </when>
              <when value="PrimaryAlignmentReadFilter"></when>
              <when value="ProperlyPairedReadFilter"></when>
              <when value="ReadGroupBlackListReadFilter">
                <param label="Read Group black list" name="blackList" type="text" value="" help="--blackList,-blackList &amp;lt;blackList&amp;gt;"/>
              </when>
              <when value="ReadGroupReadFilter">
                <param label="Read group name to keep" name="keepReadGroup" type="text" value="" help="--keepReadGroup,-keepReadGroup &amp;lt;keepReadGroup&amp;gt;"/>
              </when>
              <when value="ReadLengthEqualsCigarLengthReadFilter"></when>
              <when value="ReadLengthReadFilter">
                <param label="Minimum read length" name="minReadLength" type="integer" value="1" help="--minReadLength,-minReadLength &amp;lt;minReadLength&amp;gt;"/>
                <param label="Maximum read length" name="maxReadLength" type="integer" value="1000" help="--maxReadLength,-maxReadLength &amp;lt;maxReadLength&amp;gt;"/>
              </when>
              <when value="ReadNameReadFilter">
                <param label="Read name to keep" name="readName" type="text" value="" help="--readName,-readName &amp;lt;readName&amp;gt;"/>
              </when>
              <when value="ReadStrandFilter">
                <param checked="false" falsevalue="" help="--keepReverse,-keepReverse &amp;lt;keepReverse&amp;gt;" label="Keep reverse strand reads" name="keepReverse" truevalue="--keepReverse" type="boolean"/>
              </when>
              <when value="SampleReadFilter">
                <param label="The name of the sample(s) to keep, filtering out all others" name="sample" type="text" value=""/>
              </when>
              <when value="SecondOfPairReadFilter"></when>
              <when value="SeqIsStoredReadFilter"></when>
              <when value="ValidAlignmentEndReadFilter"></when>
              <when value="ValidAlignmentStartReadFilter"></when>
              <when value="WellformedReadFilter"></when>
            </conditional>
        </repeat>
        <param help="--disableReadFilter,-DF &amp;lt;disableReadFilter&amp;gt;" label="Read filters to be disabled before analysis" name="disableReadFilter" type="select" multiple="true">
          <option value="AlignmentAgreesWithHeaderReadFilter">AlignmentAgreesWithHeaderReadFilter</option>
          <option value="AllowAllReadsReadFilter">AllowAllReadsReadFilter</option>
          <option value="AmbiguousBaseReadFilter">AmbiguousBaseReadFilter</option>
          <option value="CigarContainsNoNOperator">CigarContainsNoNOperator</option>
          <option value="FirstOfPairReadFilter">FirstOfPairReadFilter</option>
          <option value="FragmentLengthReadFilter">FragmentLengthReadFilter</option>
          <option value="GoodCigarReadFilter">GoodCigarReadFilter</option>
          <option value="HasReadGroupReadFilter">HasReadGroupReadFilter</option>
          <option value="LibraryReadFilter">LibraryReadFilter</option>
          <option value="MappedReadFilter">MappedReadFilter</option>
          <option value="MappingQualityAvailableReadFilter">MappingQualityAvailableReadFilter</option>
          <option value="MappingQualityNotZeroReadFilter">MappingQualityNotZeroReadFilter</option>
          <option value="MappingQualityReadFilter">MappingQualityReadFilter</option>
          <option value="MatchingBasesAndQualsReadFilter">MatchingBasesAndQualsReadFilter</option>
          <option value="MateDifferentStrandReadFilter">MateDifferentStrandReadFilter</option>
          <option value="MateOnSameContigOrNoMappedMateReadFilter">MateOnSameContigOrNoMappedMateReadFilter</option>
          <option value="MetricsReadFilter">MetricsReadFilter</option>
          <option value="NonZeroFragmentLengthReadFilter">NonZeroFragmentLengthReadFilter</option>
          <option value="NonZeroReferenceLengthAlignmentReadFilter">NonZeroReferenceLengthAlignmentReadFilter</option>
          <option value="NotDuplicateReadFilter">NotDuplicateReadFilter</option>
          <option value="NotSecondaryAlignmentReadFilter">NotSecondaryAlignmentReadFilter</option>
          <option value="NotSupplementaryAlignmentReadFilter">NotSupplementaryAlignmentReadFilter</option>
          <option value="OverclippedReadFilter">OverclippedReadFilter</option>
          <option value="PairedReadFilter">PairedReadFilter</option>
          <option value="PassesVendorQualityCheckReadFilter">PassesVendorQualityCheckReadFilter</option>
          <option value="PlatformReadFilter">PlatformReadFilter</option>
          <option value="PlatformUnitReadFilter">PlatformUnitReadFilter</option>
          <option value="PrimaryAlignmentReadFilter">PrimaryAlignmentReadFilter</option>
          <option value="ProperlyPairedReadFilter">ProperlyPairedReadFilter</option>
          <option value="ReadGroupBlackListReadFilter">ReadGroupBlackListReadFilter</option>
          <option value="ReadGroupReadFilter">ReadGroupReadFilter</option>
          <option value="ReadLengthEqualsCigarLengthReadFilter">ReadLengthEqualsCigarLengthReadFilter</option>
          <option value="ReadLengthReadFilter">ReadLengthReadFilter</option>
          <option value="ReadNameReadFilter">ReadNameReadFilter</option>
          <option value="ReadStrandFilter">ReadStrandFilter</option>
          <option value="SampleReadFilter">SampleReadFilter</option>
          <option value="SecondOfPairReadFilter">SecondOfPairReadFilter</option>
          <option value="SeqIsStoredReadFilter">SeqIsStoredReadFilter</option>
          <option value="ValidAlignmentEndReadFilter">ValidAlignmentEndReadFilter</option>
          <option value="ValidAlignmentStartReadFilter">ValidAlignmentStartReadFilter</option>
          <option value="WellformedReadFilter">WellformedReadFilter</option>
        </param>
        <param label="Read validation stringency" name="readValidationStringency" type="select" help="--readValidationStringency,-VS &amp;lt;keepReadGroup&amp;gt;: Validation stringency for all SAM files read by this program">
          <option value="STRICT">STRICT</option>
          <option value="LENIENT">LENIENT</option>
          <option value="SILENT" selected="true">SILENT</option>
        </param>
        <param checked="false" falsevalue="" help="--disableSequenceDictionaryValidation: If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk!" label="Disable Sequence Dictionalry Validation" name="disableSequenceDictionaryValidation" truevalue="--disableSequenceDictionaryValidation" type="boolean"/>
        <param checked="false" falsevalue="" help="--disableToolDefaultReadFilters" label="Disable Tool Default Read Filters" name="disableToolDefaultReadFilters" truevalue="--disableToolDefaultReadFilters" type="boolean"/>
        <param checked="false" falsevalue="" help="--lenient; -LE" label="Lenient processing of VCF files" name="lenient" truevalue="--lenient" type="boolean"/>

      </when>
    </conditional>
  </inputs>
  <outputs>
    <data format="vcf" label="${tool.name} on ${on_string} (VCF File)" name="output_vcf"/>
  </outputs>
  <tests>
      <test>
          <param name="reference_source_selector" value="history"/>
          <param ftype="fasta" name="ref_file" value="phiX.fasta"/>
          <param ftype="bam" name="input_bam" value="gatk/gatk_indel_realigner/gatk_indel_realigner_out_1.bam"/>
          <param name="rod_bind_type_selector" value="dbsnp"/>
          <param ftype="bed" name="input_rod" value="gatk/fake_phiX_variant_locations.bed"/>
          <param name="standard_covs" value="True"/>
          <param name="covariates" value="ReadGroupCovariate,HomopolymerCovariate,MinimumNQSCovariate,PositionCovariate"/>
          <param name="gatk_param_type_selector" value="basic"/>
          <param name="analysis_param_type_selector" value="basic"/>
          <output file="gatk/gatk_count_covariates/gatk_count_covariates_out_1.csv" name="output_recal"/> 
          <output compare="contains" file="gatk/gatk_count_covariates/gatk_count_covariates_out_1.log.contains" name="output_log"/>
      </test>
  </tests>
  <help>
.. class:: warningmark

"This calculation is critically dependent on being able to skip over known variant sites. Please provide a dbSNP ROD or a VCF file containing known sites of genetic variation."
  
**What it does**

This walker is designed to work as the first pass in a two-pass processing step. It does a by-locus traversal operating only at sites that are not in dbSNP. We assume that all reference mismatches we see are therefore errors and indicative of poor base quality. This walker generates tables based on various user-specified covariates (such as read group, reported quality score, cycle, and dinucleotide) Since there is a large amount of data one can then calculate an empirical probability of error given the particular covariates seen at this site, where p(error) = num mismatches / num observations The output file is a CSV list of (the several covariate values, num observations, num mismatches, empirical quality score) The first non-comment line of the output file gives the name of the covariates that were used for this calculation.  Note: ReadGroupCovariate and QualityScoreCovariate are required covariates and will be added for the user regardless of whether or not they were specified Note: This walker is designed to be used in conjunction with TableRecalibrationWalker.

For more information on base quality score recalibration using the GATK, see this `tool specific page &lt;http://www.broadinstitute.org/gatk/gatkdocs/org_broadinstitute_sting_gatk_walkers_bqsr_BaseRecalibrator.html&gt;`_.

To learn about best practices for variant detection using GATK, see this `overview &lt;http://www.broadinstitute.org/gatk/guide/topic?name=best-practices&gt;`_.

If you encounter errors, please view the `GATK FAQ &lt;http://www.broadinstitute.org/gatk/guide/topic?name=faqs&gt;`_.

------

**Inputs**

GenomeAnalysisTK: BaseRecalibrator accepts an aligned BAM input file.


**Outputs**

The output is in CSV format.


Go `here &lt;http://www.broadinstitute.org/gatk/guide/topic?name=intro&gt;`_ for details on GATK file formats.

-------

**Citation**

For the underlying tool, please cite `DePristo MA, Banks E, Poplin R, Garimella KV, Maguire JR, Hartl C, Philippakis AA, del Angel G, Rivas MA, Hanna M, McKenna A, Fennell TJ, Kernytsky AM, Sivachenko AY, Cibulskis K, Gabriel SB, Altshuler D, Daly MJ. A framework for variation discovery and genotyping using next-generation DNA sequencing data. Nat Genet. 2011 May;43(5):491-8. &lt;http://www.ncbi.nlm.nih.gov/pubmed/21478889&gt;`_

Please also site `McKenna A, Hanna M, Banks E, Sivachenko A, Cibulskis K, Kernytsky A, Garimella K, Altshuler D, Gabriel S, Daly M, DePristo MA (2010). The Genome Analysis Toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data. Genome Res. 20:1297-303. Epub 2010 Jul 19. &lt;http://www.ncbi.nlm.nih.gov/pubmed/20644199&gt;`_

If you use this tool in Galaxy, please cite `Blankenberg D, Von Kuster G, Coraor N, Ananda G, Lazarus R, Mangan M, Nekrutenko A, Taylor J. Galaxy: a web-based genome analysis tool for experimentalists. Curr Protoc Mol Biol. 2010 Jan;Chapter 19:Unit 19.10.1-21. &lt;http://www.ncbi.nlm.nih.gov/pubmed/20069535&gt;`_

  </help>
</tool>
